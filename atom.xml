<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林中小屋</title>
  
  <subtitle>宁静致远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leo-wj910729.github.io/"/>
  <updated>2019-06-08T01:22:23.553Z</updated>
  <id>https://leo-wj910729.github.io/</id>
  
  <author>
    <name>Henry Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue项目格式化</title>
    <link href="https://leo-wj910729.github.io/2019/05/15/vue%E9%A1%B9%E7%9B%AE%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <id>https://leo-wj910729.github.io/2019/05/15/vue项目格式化/</id>
    <published>2019-05-15T06:57:58.000Z</published>
    <updated>2019-06-08T01:22:23.553Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><p>vscode中开发vue项目,用到的几个格式化代码的工具</p><p>vscode自带的格式化 vetur 对vue后缀的文件进行格式化,分别格式化template style script,可配置相应的格式化工具 vue-style-beautify 因prettier会自动将style中的大写px格式化为小写的px,使用其可以避免该问题,内置对样式属性的排序功能</p><h3>vetur的相关配置</h3><blockquote><p>对vue文件的代码做高亮展示</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.scss"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.postcss"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"vetur.format.defaultFormatter.css"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"vetur.format.options.useTabs"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"vueStyle.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h3>vue-style-beautify</h3><blockquote><p>这是一个专门为vue文件样式格式化的插件,特点是会按照csscomb的规则对css样式进行排序 优点是格式化时不会将大写的PX转译为小写的px 其缺点是会将文件全部展开</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;vscode中开发vue项目,用到的几个格式化代码的工具&lt;/p&gt;&lt;p&gt;vscode自带的格式化 vetur 对vue后缀的文件进行格式化,分别格
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NodeJs的path模块</title>
    <link href="https://leo-wj910729.github.io/2019/04/30/NodeJs%E7%9A%84path%E6%A8%A1%E5%9D%97/"/>
    <id>https://leo-wj910729.github.io/2019/04/30/NodeJs的path模块/</id>
    <published>2019-04-30T05:36:39.000Z</published>
    <updated>2019-04-30T06:51:56.074Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>方法</h2><ol><li>path.normalize(路径) 规范化路径</li><li>path.join(path1,path2,path3,path4....) 用于连接路径,该方法会正确使用系统路径分隔符</li><li>path.reslove([from...],to) 将to参数解析为绝对路径,给定的路径的序列是从右向左被处理的,后面的path依次解析,直到构建出一个完成的path路径</li><li>path.isAbsolute(path) 判断路径是否为绝对路径</li><li>path.relative(from, to) 返回从from 到 to的相对路径</li><li>path.dirname(path) 返回路径中代表文件夹的部分</li><li>path.basename(path) 返回路径中的最后部分</li><li>path.parse(pathString) 返回路径字符串的对象</li><li>path.format(pathObject) 从对象中返回路径字符串</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;方法&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;path.normalize(路径) 规范化路径&lt;/li&gt;&lt;li&gt;path.join(path1,path2,p
      
    
    </summary>
    
    
      <category term="Node" scheme="https://leo-wj910729.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>为何使用void0代替undefined</title>
    <link href="https://leo-wj910729.github.io/2019/04/29/%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8void0%E4%BB%A3%E6%9B%BFundefined/"/>
    <id>https://leo-wj910729.github.io/2019/04/29/为何使用void0代替undefined/</id>
    <published>2019-04-29T06:39:20.000Z</published>
    <updated>2019-04-29T06:44:19.733Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>原因</h2><p>在javascript中undefined是变量而非关键字,这导致了使用undefined作为变量时,是可以随意赋值的,其值可变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p></p><h2>实际情况</h2><p>在IE8以上的浏览器中,全局作用域下undefined值不可变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p></p><p>在IE8中的浏览器中,全局作用域下undefined值可以更改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p></p><p>在IE8以上的浏览器中,块级作用域下的undefined值可以更改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="literal">undefined</span>);  <span class="comment">//2 </span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;原因&lt;/h2&gt;&lt;p&gt;在javascript中undefined是变量而非关键字,这导致了使用undefined作为变量时,是可以随意赋值的,其
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6之let与const</title>
    <link href="https://leo-wj910729.github.io/2019/04/29/ES6%E4%B9%8Blet%E4%B8%8Econst/"/>
    <id>https://leo-wj910729.github.io/2019/04/29/ES6之let与const/</id>
    <published>2019-04-29T06:02:45.000Z</published>
    <updated>2019-04-29T06:16:59.584Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>let</h2><p>用于声明变量,会在当前作用域下形成块级作用域,其声明的变量不在受外部作用域影响</p><h3>特性</h3><p>使用let声明的变量,不会出现变量提升,意味着在声明前调用会报错</p><h3>用法</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>注意事项</h3><p>在未声明前调用变量会报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 报错 未定义</span></span><br><span class="line"><span class="keyword">let</span> b </span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> a = a <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p></p><h2>const</h2><p>用于声明常量</p><h3>特性</h3><p>声明时必须初始化,也就是赋值,初始化后不可修改,声明前调用变量会报错</p><h3>用法</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 报错 未定义</span></span><br><span class="line"><span class="keyword">const</span> b <span class="comment">// 报错 声明时就必须初始化,且不可在修改</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">2</span> <span class="comment">// 报错 不可以修改</span></span><br></pre></td></tr></table></figure><p></p><h3>注意事项</h3><p>const声明的对象是可以修改属性的,造成这一的原因主要是因为声明的对象变量中保存的是对象的内存指针,修改对象本身的属性并不会引起对象指针的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;</span><br><span class="line">a.b = <span class="number">2</span> </span><br><span class="line"><span class="built_in">console</span>.log(a.b) <span class="comment">// 2</span></span><br><span class="line">a = &#123;&#125; <span class="comment">// 报错 重新赋值对象会导致指针变化,所以会报错</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;let&lt;/h2&gt;&lt;p&gt;用于声明变量,会在当前作用域下形成块级作用域,其声明的变量不在受外部作用域影响&lt;/p&gt;&lt;h3&gt;特性&lt;/h3&gt;&lt;p&gt;使用l
      
    
    </summary>
    
    
      <category term="es6" scheme="https://leo-wj910729.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>如何解决canvas绘制时出现的闪屏问题</title>
    <link href="https://leo-wj910729.github.io/2019/04/28/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3canvas%E7%BB%98%E5%88%B6%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AA%E5%B1%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://leo-wj910729.github.io/2019/04/28/如何解决canvas绘制时出现的闪屏问题/</id>
    <published>2019-04-28T12:38:01.000Z</published>
    <updated>2019-04-28T13:07:36.699Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>问题代码</h2><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshCanvas</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span><br><span class="line">  <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">  <span class="comment">// 清除画布</span></span><br><span class="line">  ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">  <span class="comment">// 重新绘制</span></span><br><span class="line">  ctx.drawImage(bg, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2>问题分析</h2><p>canvas在清除画布时,如果绘制时间过长,则会导致出现闪屏的问题</p><h2>解决方案</h2><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">refreshCanvas</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span><br><span class="line">  <span class="keyword">const</span> tempcanvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span><br><span class="line">  <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">  <span class="keyword">const</span> tempctx = tempcanvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">  tempctx.width = <span class="built_in">window</span>.screen.width</span><br><span class="line">  tempctx.height = <span class="built_in">window</span>.screen.height</span><br><span class="line">  <span class="comment">// 缓存canvas绘制</span></span><br><span class="line">  tempCtx.drawImage(bg,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// 背景</span></span><br><span class="line">  <span class="comment">// 目标canvas清除画布</span></span><br><span class="line">  ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>, canvas.width, canvas.height)</span><br><span class="line">  <span class="comment">// 目标canvas重新绘制</span></span><br><span class="line">  ctx.drawImage(tempcanvas, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;问题代码&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="canvas" scheme="https://leo-wj910729.github.io/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的回流与重绘</title>
    <link href="https://leo-wj910729.github.io/2019/04/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98/"/>
    <id>https://leo-wj910729.github.io/2019/04/28/浏览器的回流与重绘/</id>
    <published>2019-04-28T06:45:57.000Z</published>
    <updated>2019-06-08T01:22:40.819Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>浏览器的渲染机制</h2><h3>渲染步骤</h3><ol><li>读取字符流,通过状态机,将字符转化为DOM节点,并构成树形结构</li><li>处理CSS,构建CSSOM树</li><li>将DOM树,与CSSOM树结合构建出渲染树</li><li>调用GPU绘制,合成图层</li></ol><p><strong>注意事项</strong></p><ul><li>构建CSSOM树时,会阻塞渲染,直至CSSOM树构建完成,所以深层的嵌套结构会导致更长的构建时间,保持层级的扁平有助于提升页面性能</li><li>越是具体的CSS选择器,执行速度越慢</li><li>js代码会阻止DOM树的构建,如果想拥有更快的首屏加载速度,则应将脚本文件,放在body标签后</li></ul><h3>Load和DOMContentLoaded的区别</h3><ul><li>Load事件表明js,css,dom,图片均加载完毕</li><li>DOMContentLoaded事件表明html被完全加载和解析,可以进行对dom节点的操作</li></ul><h3>图层</h3><p>正常的文档流是一个图层,一些特别的属性可以生成一个新的图层,不同图层的渲染互不影响<br>如果想对DOM节点进行持续的操作,最好将DOM节点生成一个新的图层<br>过多的图层依然会引起页面性能的下降</p><p><strong>以下几个属性和标签会产生新的图层</strong></p><ol><li>transfrom: translateZ(0) transfrom: translate3d()</li><li>will-change</li><li>video,iframe标签</li><li>position: fixed</li><li>opacity</li></ol><h2>回流与重绘</h2><h3>概念</h3><h3>回流与重绘和Event loop的关系</h3><h3>如何触发回流与重绘</h3><h3>如何减少回流与重绘</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;浏览器的渲染机制&lt;/h2&gt;&lt;h3&gt;渲染步骤&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;读取字符流,通过状态机,将字符转化为DOM节点,并构成树形结构&lt;/li&gt;&lt;
      
    
    </summary>
    
    
      <category term="browser" scheme="https://leo-wj910729.github.io/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>浏览器存储方案</title>
    <link href="https://leo-wj910729.github.io/2019/04/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/"/>
    <id>https://leo-wj910729.github.io/2019/04/26/浏览器存储方案/</id>
    <published>2019-04-26T07:08:13.000Z</published>
    <updated>2019-04-28T07:14:00.921Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>确立目标</h2><p>理解cookie,sessionstorage,localstorage,indexDB等浏览器存储数据方案的使用方法,优缺点</p><h2>学习理解</h2><h3>cookie</h3><h4>特征</h4><ul><li>不同浏览器存储cookie的位置不同,所以不能通用</li><li>不同域下的cookie是独立的</li><li>我们能够操作的cookie,是在当前域,和当前域的子域中</li><li>一个域下可存储的cookie有限(20个左右)</li><li>存放大小也有限制(4kb)</li><li>cookie可以设置过期时间(默认会话结束就销毁)</li></ul><h4>配置项</h4><h5>expires</h5><p>expires用于设定cookie的有效时间,默认为会话结束后(浏览器窗口关闭)<br>expires必须是GMT格式的时间,可以通过new Date().toGMTString()或者 new Date().toUTCString()来获得</p><h5>domain,path</h5><p>domain和path共同确定了cookie的作用域,如果路径匹配成功,则会被添加到请求的头部中,如果没有设置,则会使用默认值<br>domain的默认值为设置该cookie的网页所在的域,path默认值为设置该cookie的网页所在的目录</p><h5>secure</h5><p>cookie通常使用http连接来传递数据,这种数据很容易被查看,所以cookie存储信息容易被窃取,当我们使用https等加密安全协议时,可以使用加密的数据传输cookie<br>secure选项用来设置cookie只会在安全的请求中才进行发送,但这样的cookie只有在传输过程中是加密的,存储到本地的cookie文件是不加密的,所以机密和敏感的信息不应该放在cookie中进行传输</p><h5>httpOnly</h5><p>cookie默认是可以通过js来进行操作的,但是如果我们不想js来操作cookie的话,可以通过设置httpOnly属性<br>设置过该属性后,客户端无法通过js代码来进行读取,写入,删除,修改等操作,这种类型的cookie只能由服务器端进行设置</p><h3>sessionstorage</h3><p><strong>特点</strong><br>数据在相同协议,端口,域名,窗口下,可以访问,且会话窗口关闭则数据被清除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.sessionStorage.setItem(key, value) <span class="comment">// value必须是字符串类型</span></span><br><span class="line"><span class="built_in">window</span>.sessionStorage.getItem(key)</span><br></pre></td></tr></table></figure><p></p><h3>localstorage</h3><p><strong>特点</strong> 数据持久化存储,相同协议,端口,域名下就可以访问并操作数据</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;确立目标&lt;/h2&gt;&lt;p&gt;理解cookie,sessionstorage,localstorage,indexDB等浏览器存储数据方案的使用方法
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="browser storage" scheme="https://leo-wj910729.github.io/tags/browser-storage/"/>
    
  </entry>
  
  <entry>
    <title>new fucntion发生了什么</title>
    <link href="https://leo-wj910729.github.io/2019/02/26/new%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://leo-wj910729.github.io/2019/02/26/new一个函数时发生了什么/</id>
    <published>2019-02-26T02:59:27.000Z</published>
    <updated>2019-04-28T06:34:38.179Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentClass</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">  <span class="keyword">this</span>.b = b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> parentClass(a,b)</span><br><span class="line">New(parentClass, a, b)</span><br><span class="line"><span class="comment">// 1.生成一个空对象</span></span><br><span class="line"><span class="comment">// 2.将该对象的原型指向到构造函数</span></span><br><span class="line"><span class="comment">// 3.函数的this属性赋值为该对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125; <span class="comment">// 生成一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">constructor</span> = [].shift.call(arguments) // 得到构造函数</span><br><span class="line">  if (<span class="keyword">constructor</span>.prototype === null) &#123; <span class="comment">// 将对象的原型指向构造函数</span></span><br><span class="line">    obj.prototype = <span class="keyword">constructor</span>.prototype</span><br><span class="line">  &#125;</span><br><span class="line">  let ret = <span class="keyword">constructor</span>.apply(obj, [].slice.call(arguments)) // 获取构造函数的返回值 </span><br><span class="line">  if ((typeof ret === 'object' || typeof ret === 'function') &amp;&amp; ret !== null) &#123; <span class="comment">// 如果构造函数有返回值,且返回值为object,function类型的话,且不等于null,则返回构造函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则返回对象</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>如何将类数组转化为数组类型</h3><ol><li>[].slice.call()</li><li>Array.from()</li></ol><p>Array.from使用时需要注意类数组的key值需要是数字</p><p>[].slice.call(arguments)将arguments转化为数组</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="function" scheme="https://leo-wj910729.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>跨域解决方案</title>
    <link href="https://leo-wj910729.github.io/2019/01/09/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://leo-wj910729.github.io/2019/01/09/跨域解决方案/</id>
    <published>2019-01-09T05:37:29.000Z</published>
    <updated>2019-04-28T06:35:29.127Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>跨域</h2><h3>原因</h3><p>浏览器出于安全考虑,有了同源原则.只要协议,域名,端口号三者有一个不同,都会被当做是不同域</p><h3>解决方案</h3><h4>JSONP</h4><p>利用script标签没有跨域限制的特性,通过把src的链接配置为接口的地址,并提供一个回调函数来接受数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsop</span>(<span class="params">url,jsonpCb, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCb] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h4>CORS</h4><p>CORS定义了必须访问跨域资源时,浏览器如何与服务器进行沟通<br>基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通,从而决定请求或响应是否成功<br>兼容性,不低于IE10<br>CORS通信的关键在服务器,服务器实现了CORS接口,就可以实现跨域通信,而浏览器端,无需做任何更改,由浏览器自动完成<br>服务器端对CORS的支持,主要是通过Access-Contril-Allow-Origin来进行,该属性用于标识哪些域名可以跨域访问,如果浏览器检测到域名匹配则可以进行跨域访问</p><h4>postMessage</h4><p>window.postMessage提供了一种受控机制来规避此限制,可以安全的实现跨源通信<br>当postMessage方法被调用时,会在页面脚本执行完毕后,会发送一个MessageEvent给目标窗口<br>MessageEvent含四个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> messageCb = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> message = event.message <span class="comment">// 消息类型,消息名称</span></span><br><span class="line">  <span class="keyword">let</span> source = event.source <span class="comment">// 消息源window对象</span></span><br><span class="line">  <span class="keyword">let</span> origin = event.origin <span class="comment">// 消息来源地址</span></span><br><span class="line">  <span class="keyword">let</span> data = event.data <span class="comment">// 发送过来的消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, messageCb, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p></p><h4>Nginx反向代理</h4><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name www.xxx.com;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pase api.xxx.com;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;跨域&lt;/h2&gt;&lt;h3&gt;原因&lt;/h3&gt;&lt;p&gt;浏览器出于安全考虑,有了同源原则.只要协议,域名,端口号三者有一个不同,都会被当做是不同域&lt;/p&gt;&lt;
      
    
    </summary>
    
    
      <category term="browser" scheme="https://leo-wj910729.github.io/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs的fs模块</title>
    <link href="https://leo-wj910729.github.io/2018/11/26/NodeJs%E7%9A%84fs%E6%A8%A1%E5%9D%97/"/>
    <id>https://leo-wj910729.github.io/2018/11/26/NodeJs的fs模块/</id>
    <published>2018-11-26T08:53:53.000Z</published>
    <updated>2019-04-30T05:36:51.069Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>fs模块</h2><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">fs.open(<span class="string">'test.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);    </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 获取文件信息</span></span><br><span class="line">fs.stat(<span class="string">'test.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, status</span>) </span>&#123;</span><br><span class="line">  status.isFile() <span class="comment">// 是否为文件</span></span><br><span class="line">  status.isDirectory() <span class="comment">// 是否为文件夹</span></span><br><span class="line">  status.isBlockDevice() <span class="comment">// 是否是块设备</span></span><br><span class="line">  status.isCharacterDevice() <span class="comment">// 是否是字符设备</span></span><br><span class="line">  status.isSymbolicLink() <span class="comment">// 是否是软链接</span></span><br><span class="line">  status.isFIFO() <span class="comment">// 是否是FIFO</span></span><br><span class="line">  status.isSocket() <span class="comment">// 是否是Socket</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h3>对文件夹的操作的一些命令总结</h3><ul><li>读取文件夹 fs.readdir(path, callback)</li><li>创建文件夹 fs.mkdir(path, cb)</li><li>删除文件夹 fs.rmdir(path, callback)</li></ul><h3>对文件的操作的一些命令总结</h3><ul><li>关闭文件 fs.close(fd, callback)</li><li>读取文件 fs.read(fd, buffer, offset, length, position, callback)</li><li>写入文件 fs.writeFile(file, data[, options], callback)</li><li>删除文件 fs.unlink(path, cb)</li><li>截取文件 fs.ftruncate(fd, len, callback)</li></ul><h3>同步与异步将文件复制至缓存区,然后从缓存区读取文件</h3><h4>同步读取文件</h4><p><strong>特点</strong> 在读取操作结束下,无法进行下一步操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = fs.readFileSync(<span class="string">'test.txt'</span>, <span class="string">'utf8'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(data) <span class="comment">// 文件数据</span></span><br></pre></td></tr></table></figure><p></p><h4>异步读取文件</h4><p><strong>特点</strong> 在读取操作结束下,可以进行下一步操作,在读取结束后,会将读取结果用参数形式传入回调函数,并执行回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'test.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">'读取失败'</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'读取成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h3>同步与异步将文件复制至缓存区,然后从缓存区写入文件中</h3><h4>同步读取文件</h4><p><strong>特点</strong> 在读取操作结束下,无法进行下一步操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFileSync(<span class="string">'test.txt'</span>, <span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure><p></p><h4>异步读取文件</h4><p><strong>特点</strong> 在读取操作结束下,可以进行下一步操作,在读取结束后,会将读取结果用参数形式传入回调函数,并执行回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">'test.txt'</span>, <span class="string">'hello world'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(<span class="string">'写文件操作失败'</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'写文件操作成功'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h3>同步或异步分块式读取文件内容</h3><blockquote><p>fs.read(fd, buffer, offset, length, position, callback)</p></blockquote><p>参数说明:</p><ul><li>fd 文件名</li><li>buffer 数据写入的缓存区</li><li>offset 缓冲区写入的偏移量</li><li>length 要读取的字符数</li><li>position 文件读取的起始位置 为null时,从文件指针位置开始</li><li>callback 回调函数</li></ul><h4>异步读取文件</h4><p><strong>特点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> Buffer(<span class="number">255</span>)</span><br><span class="line">fs.read(<span class="string">'test.txt'</span>, buffer, <span class="number">0</span>, <span class="number">3</span>, <span class="literal">null</span>,<span class="function"><span class="keyword">function</span> (<span class="params">err,bytesRead,buffer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(<span class="string">'写文件操作失败'</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">console</span>.log(<span class="string">'写文件操作成功'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h4>同步读取文件</h4><p><strong>特点</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.readSync(<span class="string">'test.txt'</span>, buff, <span class="number">0</span>, <span class="number">3</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p></p><h3>创建一个读取/写入流</h3><p>fs.createReadStream('test.txt')</p><h4>读取流</h4><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> readStream = fs.createReadStream(<span class="string">'./message.txt'</span>, &#123;<span class="attr">start</span>:<span class="number">3</span>,<span class="attr">end</span>:<span class="number">12</span>&#125;);</span><br><span class="line">readStream.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">fd</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始读取文件'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取到数据：'</span>, data);</span><br><span class="line">&#125;);</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'文件已全部读取完毕'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">readStream.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'文件被关闭'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">readStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'读取文件失败'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h4>写入流</h4><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> file = fs.createReadStream(<span class="string">'./message.txt'</span>);</span><br><span class="line"><span class="keyword">let</span> out = fs.createWriteStream(<span class="string">'./anotherMessage.txt'</span>);</span><br><span class="line">file.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  out.write(data);</span><br><span class="line">&#125;);</span><br><span class="line">out.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">fd</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'需要被写入的文件已打开'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">file.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//将操作系统缓存区中的数据全部写入文件</span></span><br><span class="line">  out.end(<span class="string">'再见'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件全部写入完毕'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'共写入'</span>+out.bytesWritten+<span class="string">'数据'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;fs模块&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="Node" scheme="https://leo-wj910729.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Git的基础操作指令</title>
    <link href="https://leo-wj910729.github.io/2018/10/13/git-base/"/>
    <id>https://leo-wj910729.github.io/2018/10/13/git-base/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2019-04-28T06:49:01.108Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h2>全局配置</h2><h3>Git操作</h3><ol><li><p>配置全局信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"henry"</span></span><br><span class="line">$ git config --global user.email henry@example.com</span><br><span class="line">$ git config --global <span class="built_in">alias</span>.&lt;<span class="built_in">alias</span>-name&gt; &lt;命令名&gt; // 设置别名 如 git ci 等价于 git commit</span><br></pre></td></tr></table></figure><p></p></li><li><p>初始化本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p></p></li><li><p>查询当前文件状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p></p></li><li><p>添加文件到git暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add 文件名</span><br><span class="line">$ git add . // 添加所有文件到暂存区</span><br></pre></td></tr></table></figure><p></p></li><li><p>提交暂存区文件到git本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'提交信息'</span></span><br><span class="line">$ git commit --amend // 重新提交</span><br></pre></td></tr></table></figure><p></p></li><li><p>撤销暂存区文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD 文件名</span><br></pre></td></tr></table></figure><p></p></li><li><p>查看远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">$ git remote -v // 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span><br></pre></td></tr></table></figure><p></p></li><li><p>添加远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;remote-name&gt; &lt;url&gt; // 添加一个新的远程Git仓库</span><br></pre></td></tr></table></figure><p></p></li><li><p>拉去远程仓库到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p></p></li><li><p>推送到远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p></p></li><li><p>修改远程仓库名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename &lt;remote-name&gt; &lt;new-remote-name&gt;</span><br></pre></td></tr></table></figure><p></p></li><li><p>删除远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p></p></li><li><p>查看所有标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">$ git tag -l <span class="string">'搜索词'</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>创建标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag  &lt;tag-name&gt; // 创建一个轻量标签</span><br><span class="line">$ git tag -a &lt;tag-name&gt; -m <span class="string">'存储在标签中的信息'</span> // -a 创建一个携带标签信息的标签 -m 标签信息</span><br><span class="line">$ git tag -a &lt;tag-name&gt; 提交的校验和（或部分校验和） // 给过去的提交打标签</span><br></pre></td></tr></table></figure><p></p></li><li><p>将标签推送到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;remote-name&gt; &lt;tag-name&gt; // 推送一个tag到远端</span><br><span class="line">$ git push &lt;remote-name&gt; --tags // 推送多个tag到远端</span><br></pre></td></tr></table></figure><p></p></li><li><p>删除标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d &lt;tag-name&gt; // 本地删除一个指定的tag</span><br><span class="line">$ git push &lt;remote-name&gt; :refs/tags/&lt;tag-name&gt; // 远端删除一个指定的tag</span><br></pre></td></tr></table></figure><p></p></li><li><p>检出标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag</span><br><span class="line">$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag</span><br></pre></td></tr></table></figure><p></p></li></ol><h3>分支操作</h3><ol><li><p>创建分支</p></li><li><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git brach -d</span><br></pre></td></tr></table></figure><p></p></li><li><p>查询分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;全局配置&lt;/h2&gt;&lt;h3&gt;Git操作&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;配置全局信息&lt;/p&gt;&lt;figure class=&quot;highlight ba
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="https://leo-wj910729.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数与普通函数的区别</title>
    <link href="https://leo-wj910729.github.io/2018/08/14/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://leo-wj910729.github.io/2018/08/14/箭头函数与普通函数的区别/</id>
    <published>2018-08-14T03:08:17.000Z</published>
    <updated>2019-04-28T06:35:01.128Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h3>箭头函数</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrowFn = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数没有arguments属性</span></span><br><span class="line">  <span class="comment">// 箭头函数没有原型属性</span></span><br><span class="line">  <span class="comment">// 箭头函数不能当做generator函数,也不能使用yield关键字</span></span><br><span class="line">  <span class="comment">// 箭头函数作用域永远指向父级作用域,call,apply,bind都无法改变</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'箭头函数'</span>, <span class="built_in">arguments</span>) <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'箭头函数'</span>, args) <span class="comment">// 因为没有arguments属性,使用...扩展符来获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数不可以作为构造函数,因为其特性,this永远指向父级作用域,而构造函数的第一步就是将this赋值为生成的空对象</span></span><br><span class="line"><span class="keyword">new</span> arrowFn() <span class="comment">// Uncaught TypeError: FunConstructor is not a constructor</span></span><br></pre></td></tr></table></figure><p></p><h3>普通函数</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> normalFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'普通函数'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h3&gt;箭头函数&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="function" scheme="https://leo-wj910729.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>函数的节流</title>
    <link href="https://leo-wj910729.github.io/2018/08/13/throttle/"/>
    <id>https://leo-wj910729.github.io/2018/08/13/throttle/</id>
    <published>2018-08-12T16:00:00.000Z</published>
    <updated>2019-06-08T01:01:45.704Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h3>定义</h3><p>当持续触发事件时,在规定的时间内只触发一次,如果在规定的时间内再次触发事件,则不做任何操作</p><h3>应用场景</h3><p>监听是否滚动到底部,而触发上拉加载</p><h3>原理</h3><ol><li>时间戳形式,通过闭包保存上一次的时间戳,将其与事件触发时的时间戳进行比较,如果差值大于设定的时间,则调用事件,并记录时间戳,否则不进行任何操作</li><li>定时器形式,通过闭包保存定时器,事件触发时,如果定时器为null,则执行cb,并设置新的定时器</li></ol><h3>实现方法</h3><ol><li><p>时间戳形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">cb, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prevTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    <span class="keyword">if</span> (now &gt; prevTime + delay) &#123;</span><br><span class="line">      fun.apply(that, _args)</span><br><span class="line">      prevTime = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>定时器形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">cb, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">        cb.apply(that, _args)</span><br><span class="line">      &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>时间戳加定时器的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">cb, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> prevTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> tag = delay - (now - prevTime)</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    <span class="keyword">if</span> (tag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      cb.apply(that, delay)</span><br><span class="line">      prevTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cb.apply(that, delay)</span><br><span class="line">      &#125;, ta)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h3&gt;定义&lt;/h3&gt;&lt;p&gt;当持续触发事件时,在规定的时间内只触发一次,如果在规定的时间内再次触发事件,则不做任何操作&lt;/p&gt;&lt;h3&gt;应用场景&lt;/h3
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="function" scheme="https://leo-wj910729.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>函数的防抖</title>
    <link href="https://leo-wj910729.github.io/2018/07/06/dounce/"/>
    <id>https://leo-wj910729.github.io/2018/07/06/dounce/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2019-04-28T06:33:34.709Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h3>定义</h3><p>触发时间后的一段时间内,该事件的回调函数仅会触发一次,如果在规定时间内再次触发该事件,则重新开始计算时间 游戏理解: 法师读条法术,进度条未读完再次释放则会打断上次施法</p><h3>应用场景</h3><ol><li>用户连续操作导致事件频发触发回调</li><li>用户只关系操作之后的结果(滚动条啊,搜索输入啊,这种)</li></ol><h3>原理</h3><p>通过定时器将回调函数进行延时,在规定时间内继续回调,发现存在之前的定时器时,清空该定时器并重新设置新的定时器</p><h3>实现方法</h3><ol><li><p>非立即执行版本: 事件触发=&gt; 延时=&gt; 执行回调函数 在延时中触发事件,则会重新进行延时,延时结束后执行回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">cb, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    clearTimeout(cb.timer)</span><br><span class="line">    cb.timer = setTimout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      cb.call(that, _args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是一个回调函数'</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> debounceFn = debounce(cb)</span><br><span class="line"><span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'test-input'</span>)</span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  debounceFn(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p></li><li><p>立即执行版本: 事件触发=&gt; 执行回调函数=&gt; 延时 在延时中触发事件,则会重新进行延时,延时结束,并不会执行回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">cb, immediate = true, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!timer) cb.apply(that, args)</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cb.apply(that, args)</span><br><span class="line">      &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><p>// 防抖就是在一段时间内如果没有操作,则执行函数,如果有操作,则清除定时器重新执行 // 节流就是在一段时间内只会触发一次函数操作</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h3&gt;定义&lt;/h3&gt;&lt;p&gt;触发时间后的一段时间内,该事件的回调函数仅会触发一次,如果在规定时间内再次触发该事件,则重新开始计算时间 游戏理解: 法师
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="function" scheme="https://leo-wj910729.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="https://leo-wj910729.github.io/2018/06/23/GarbageCollection/"/>
    <id>https://leo-wj910729.github.io/2018/06/23/GarbageCollection/</id>
    <published>2018-06-22T16:00:00.000Z</published>
    <updated>2019-04-28T06:33:08.785Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><h1>垃圾回收机制</h1><p><strong>javascript</strong>有内置的垃圾回收机制GC,执行环境在管理代码执行过程中使用的内存,内存的分配和回收全都由js引擎来管理</p><h2>内存生命周期</h2><ol><li>内存分配阶段: 声明变量,函数,对象并执行时,系统会自动为其分配内存</li><li>内存使用阶段: 使用变量,函数时</li><li>内存回收阶段: 变量,函数被使用完毕,由GC机制回收</li></ol><h2>垃圾回收机制的策略</h2><h3>标记清除法: mark-and-sweep</h3><p><strong>算法:</strong></p><ol><li>标记阶段: GC从根开始遍历,凡是可以到达根的对象,都是仍需要使用的对象,被标记</li><li>清除阶段: GC会对堆内存从头到尾进行线性遍历,发现对象没有被标记则将其占用的内存回收,标记了的对象被去除标记</li></ol><p><strong>缺陷</strong></p><ol><li>不能从根对象查询到的对象都会被清除</li><li>GC后会产生大量的内存碎片,因为对象需要连续的内存单位,可能会导致内存碎片持续未被使用,直到内存溢出</li></ol><hr><h3>引用计数法</h3><p><strong>算法:</strong><br>对象是否未被其他对象引用</p><p><strong>缺陷:</strong><br>无法处理循环引用,创建两个对象,互相引用,则这两个对象永远无法被垃圾回收,从而导致内存溢出</p><hr><h3>V8垃圾回收算法</h3><p>chrome的v8引擎采用了分代回收策略,将内存对象分为临时对象和持久对象<br>临时对象和持久对象的回收机制并不相同<br>因为GC会导致js线程暂停执行,一次较长的GC可能会持续1s以上的时间,所以通过持续回收临时对象来减少GC的执行时间</p><hr><h3>V8的内存限制</h3><p>在node中javascript可使用的内存有限制</p><blockquote><ol><li>64位系统下约1.4GB,临时对象存储空间约32MB</li><li>32位系统下约0.7GB,临时对象存储空间约16MB</li></ol></blockquote><h4>临时对象</h4><p>临时对象的存储空间将会被均分为两块,只有一块处于使用状态,其被称为FROM空间,另一块则闲置,被称为TO空间 GC时,将FROM空间中的临时对象中的存活对象进行标记,GC结束后将被标记对象复制到TO空间中,将FROM空间的内存清空,此时FROM空间与TO空间角色互换,如此循环<br>**缺陷:**减少了空间的使用,换来了时间上的节省<br>**优点:**极其适合临时对象的垃圾回收,因为临时对象生命周期短,适合该算法</p><h5>晋升机制</h5><p>当一个对象经过多次复制后依然存在,其就会被标记为持久对象,被移动至持久对象存储空间中</p><h5>晋升条件</h5><ol><li>对象经历过临时存储空间的GC</li><li>临时存储空间中的TO空间被占据25%以上</li></ol><h4>持久对象</h4><p>持久对象的存储空间较大,存储的对象较多,使用临时对象的那种GC算法牺牲的空间太大,而且持久对象的生命周期较长<br>持久对象的GC算法为mark-and-sweep,即标记-清除,标记非活跃对象,清除非活跃对象 但是mark-and-sweep会导致内存不连续,产生大量的内存碎片,导致内存溢出的可能性 为了解决上述问题引入了一种新的算法Mark-compact,即标记-排列整理,在标记后,将活跃对象往一端移动,移动完成后,清除边界外的内存,但该种算法的执行速度较慢,所以仅在临时对象晋升后的内存分配时使用</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;h1&gt;垃圾回收机制&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;javascript&lt;/strong&gt;有内置的垃圾回收机制GC,执行环境在管理代码执行过程中使用的
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="https://leo-wj910729.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://leo-wj910729.github.io/2018/06/21/algorithm-shellsort/"/>
    <id>https://leo-wj910729.github.io/2018/06/21/algorithm-shellsort/</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2019-04-28T06:32:41.146Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><hr><h2>算法介绍</h2><h3>1.1 算法描述</h3><p>希尔排序是建立在插入排序上的改进排序方法,对排序情况较好的序列排序时,能够达到较好的排序效率</p><h3>1.2 算法步骤</h3><ol><li>选择一个增量序列,t1, t2, ....,tj,tk 依次减少,最小为1</li><li>按照增量序列的个数,对序列进行k次排序</li><li>每次排序根据对应的增量ti,将待排序列分割成若干长度为m的子序列,分别对各子表进行直接插入排序.</li></ol><h3>1.3 算法实现</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">funtion shellSort (arr) &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length</span><br><span class="line">  <span class="keyword">let</span> temp</span><br><span class="line">  <span class="keyword">let</span> gap = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">2</span>) &#123;</span><br><span class="line">    gap = gap * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      temp = arr[i] <span class="comment">// 按照步进值取出对应的分块数据 arr[2]和arr[0]配对 依次类推   </span></span><br><span class="line">      <span class="comment">// 该gap值下所分的组进行插值排序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        <span class="comment">// arr[j] &gt; arr[i] 前值大于后值</span></span><br><span class="line">        arr[j+gap] = arr[j] <span class="comment">// 将前值赋值给后值</span></span><br><span class="line">      &#125;</span><br><span class="line">      arr[j+gap] = temp <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;h2&gt;算法介绍&lt;/h2&gt;&lt;h3&gt;1.1 算法描述&lt;/h3&gt;&lt;p&gt;希尔排序是建立在插入排序上的改进排序方法,对排序情况较好的序列排序时,能够达
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="algorithm" scheme="https://leo-wj910729.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>nrm的使用</title>
    <link href="https://leo-wj910729.github.io/2018/05/20/nrm/"/>
    <id>https://leo-wj910729.github.io/2018/05/20/nrm/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2019-06-07T12:23:19.862Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><hr><h2>安装 (已安装git的情况下)</h2><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br><span class="line">$ 或者</span><br><span class="line">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br></pre></td></tr></table></figure><p></p><h2>设置全局路径</h2><blockquote><p>这四个文件中的一个 ~/.bashrc, ~/.bash_profile, ~/.zshrc, ~/.profile 文件下添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span> [ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">$ <span class="built_in">source</span> .bash_profile // 启用</span><br><span class="line">$ nvm ls // 测试</span><br></pre></td></tr></table></figure><p></p></blockquote><h2>使用</h2><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm ls // 展示现有node版本列表</span><br></pre></td></tr></table></figure><p></p><h2>卸载</h2><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ rm -rf .nvm</span><br><span class="line">$ // 去除上面设置的全局路径</span><br><span class="line">$ source .bash_profile</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;h2&gt;安装 (已安装git的情况下)&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="nrm" scheme="https://leo-wj910729.github.io/tags/nrm/"/>
    
  </entry>
  
  <entry>
    <title>手撕api系列</title>
    <link href="https://leo-wj910729.github.io/2018/05/20/%E6%89%8B%E6%92%95%E7%B3%BB%E5%88%97/"/>
    <id>https://leo-wj910729.github.io/2018/05/20/手撕系列/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2019-06-08T01:39:32.019Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><hr><h2>手撕api系列</h2><h3>实现bind函数</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> me = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  F.prototype = me.prototype</span><br><span class="line">  <span class="keyword">let</span> bound =  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fnArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> finalArgs = args.concat(fnArgs)</span><br><span class="line">    <span class="keyword">return</span> me.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> F ? <span class="keyword">this</span> : context || <span class="keyword">this</span>, finalArgs)</span><br><span class="line">  &#125;</span><br><span class="line">  bound.prototype = <span class="keyword">new</span> F() <span class="comment">// bound生成的实例使用instanceof 会指向 bind的 this</span></span><br><span class="line">  <span class="keyword">return</span> bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>实现call函数</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="built_in">Function</span>.prototype.call || <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> me = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">return</span> me()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>实现map函数</h3><h4>使用for循环实现map</h4><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.map = <span class="built_in">Function</span>.prototype.map || <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(me + <span class="string">'is not a Array'</span>)</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(me)</span><br><span class="line">  <span class="keyword">var</span> mapedArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.hasOwnProperty[i]) <span class="keyword">continue</span></span><br><span class="line">    mapedArr.push(fn.call(context, arr[i], i, <span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mapedArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4>使用reduce实现map</h4><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.map = <span class="built_in">Function</span>.prototype.map || <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(me + <span class="string">'is not a Array'</span>)</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(me)</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">pre, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...pre, fn.call(context, cur, index, <span class="keyword">this</span>)]</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>实现reduce函数</h3><p><strong>reduce函数</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">处理函数 function(total,currentValue, index,arr)</td><td style="text-align:center">必需。用于执行每个数组元素的函数</td></tr><tr><td style="text-align:center">initialValue</td><td style="text-align:center">可选。传递给函数的初始值</td></tr></tbody></table><p><strong>处理函数</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">total</td><td style="text-align:center">必须,初始值或计算结束后的返回值</td></tr><tr><td style="text-align:center">currentValue</td><td style="text-align:center">必须,当前元素</td></tr><tr><td style="text-align:center">currentIndex</td><td style="text-align:center">可选,当前元素索引</td></tr><tr><td style="text-align:center">arr</td><td style="text-align:center">可选,当前元素所属的数组对象</td></tr></tbody></table><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.reduce = <span class="built_in">Array</span>.prototype.reduce || <span class="function"><span class="keyword">function</span> (<span class="params">fn, initValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (!(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(arr + <span class="string">'is not a array'</span>)</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> base = <span class="keyword">typeof</span> initValue === <span class="string">'undefined'</span> ? arr[<span class="number">0</span>] : initValue</span><br><span class="line">  <span class="keyword">let</span> initIndex = <span class="keyword">typeof</span> initValue === <span class="string">'undefined'</span> ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">  arr.slice(initIndex).forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    base = fn(base, item, initIndex + index, arr)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>实现some函数</h3><p><strong>some函数</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">处理函数 function(total,currentValue, index,arr)</td><td style="text-align:center">必需。用于执行每个数组元素的函数</td></tr><tr><td style="text-align:center">thisValue</td><td style="text-align:center">可选。对象作为该执行回调时使用，传递给函数，用作 &quot;this&quot; 的值</td></tr></tbody></table><p><strong>处理函数</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">currentValue</td><td style="text-align:center">必须,当前元素</td></tr><tr><td style="text-align:center">currentIndex</td><td style="text-align:center">可选,当前元素索引</td></tr><tr><td style="text-align:center">arr</td><td style="text-align:center">可选,当前元素所属的数组对象</td></tr></tbody></table><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.some = <span class="built_in">Array</span>.prototype.some || <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="keyword">this</span> + <span class="string">'is not a Array'</span>)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.length) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">var</span> tag = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">var</span> len = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.hasOwnProperty(i)) <span class="keyword">continue</span></span><br><span class="line">    tag = fn.call(context, item, index, arr))</span><br><span class="line">    <span class="keyword">if</span> (tag) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>实现filter函数</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.filter = <span class="built_in">Array</span>.prototype.filter || <span class="function"><span class="keyword">function</span> (<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="keyword">this</span> + <span class="string">'is not a Array'</span>)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.length) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">let</span> ret = []</span><br><span class="line">  <span class="keyword">this</span>.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    fn.call(context, item, index, <span class="keyword">this</span>) &amp;&amp; ret.push(result)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>实现promise函数</h3><h3>实现curry函数</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">funciton curry (...fns) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    fns.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn.call(<span class="literal">null</span>, args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">curry(fn1, fn2, fn3)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p></p><h3>实现new</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">constructor</span> = args.shift()</span><br><span class="line">  let obj = Object.create(construtor)</span><br><span class="line">  let result = <span class="keyword">constructor</span>.apply(obj, args)</span><br><span class="line">  return (typeof result === 'Object' &amp;&amp; result !== 'null') ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>实现Object.assign</h3><h3>使用reduce函数实现compose和pipe</h3><h3>函数节流</h3><blockquote><p>函数节流=&gt; 规定时间内多次触发,只会有一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (_now - _start &gt;= delay) &#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">      nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h3>函数防抖</h3><blockquote><p>函数防抖=&gt; 规定时间内多次触发,在规定时间内多次触发,会取消上一次触发的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">      fn.apply(context, <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>))</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;h2&gt;手撕api系列&lt;/h2&gt;&lt;h3&gt;实现bind函数&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight javasc
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="es6" scheme="https://leo-wj910729.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://leo-wj910729.github.io/2018/05/20/algorithm-quicksort/"/>
    <id>https://leo-wj910729.github.io/2018/05/20/algorithm-quicksort/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2019-06-08T01:08:02.576Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><hr><h2>算法介绍</h2><h3>1.1 算法描述</h3><p>快速排序因为时间复杂度较低,且其核心思想分治法实用性强,算法难度不高,使其流行度较高</p><h3>1.2 算法步骤</h3><ol><li>从数组中取出一个数作为基数</li><li>对数组进行遍历,将大于该数的数放在基数的右边,小于该数的放在基数的左边</li><li>对左侧和右侧的数组继续进行上述操作,直至左右侧只有一位数</li></ol><h3>1.3 算法实现</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">funtion quickSort (arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.isArray) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">let</span> baseIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> baseNumber = arr.splice(baseIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left = []</span><br><span class="line">  <span class="keyword">let</span> right = []</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item &lt; baseNumber) left.push(item)</span><br><span class="line">    <span class="keyword">else</span> right.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat(baseNumber,quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;h2&gt;算法介绍&lt;/h2&gt;&lt;h3&gt;1.1 算法描述&lt;/h3&gt;&lt;p&gt;快速排序因为时间复杂度较低,且其核心思想分治法实用性强,算法难度不高,使其流
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="algorithm" scheme="https://leo-wj910729.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>docker基础知识</title>
    <link href="https://leo-wj910729.github.io/2018/03/26/dcoker-base/"/>
    <id>https://leo-wj910729.github.io/2018/03/26/dcoker-base/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2019-04-24T03:00:58.466Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --><hr><h3>docker的核心</h3><hr><h4>镜像</h4><p>可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。  每次对镜像的修改都会产生一个新的镜像层,该镜像层基于修改前的镜像。  镜像内存储的是不可变的文件。</p><h4>容器</h4><p>用于隔离虚拟环境的基础设施。  如果将镜像比作类,那么容器就是类的实例  容器是活的空间,内部文件可变</p><h4>网络</h4><p>利用一些技术,DOcker能够在容器中营造出独立的域名解析环境,这意味着我们不需要付出任何代价就可以创造出同一环境的容器  两台物理机上的docker容器,可以加入同一个虚拟网络中</p><h4>数据卷</h4><p>可以挂载在宿主操作系统中的目录上  容器内建立独立的目录持久存放数据  容器间共享</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Jun 08 2019 09:40:23 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;h3&gt;docker的核心&lt;/h3&gt;&lt;hr&gt;&lt;h4&gt;镜像&lt;/h4&gt;&lt;p&gt;可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容
      
    
    </summary>
    
    
      <category term="docker" scheme="https://leo-wj910729.github.io/tags/docker/"/>
    
  </entry>
  
</feed>
