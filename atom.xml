<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林中小屋</title>
  
  <subtitle>宁静致远</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://leo-wj910729.github.io/"/>
  <updated>2019-04-28T03:23:57.449Z</updated>
  <id>https://leo-wj910729.github.io/</id>
  
  <author>
    <name>Henry Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器存储方案</title>
    <link href="https://leo-wj910729.github.io/2019/04/26/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/"/>
    <id>https://leo-wj910729.github.io/2019/04/26/浏览器存储方案/</id>
    <published>2019-04-26T07:08:13.000Z</published>
    <updated>2019-04-28T03:23:57.449Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h2>确立目标</h2><p>理解cookie,sessionstorage,localstorage,indexDB等浏览器存储数据方案的使用方法,优缺点</p><h2>学习理解</h2><h3>cookie</h3><h4>特征</h4><ul><li>不同浏览器存储cookie的位置不同,所以不能通用</li><li>不同域下的cookie是独立的</li><li>我们能够操作的cookie,是在当前域,和当前域的子域中</li><li>一个域下可存储的cookie有限(20个左右)</li><li>存放大小也有限制(4kb)</li><li>cookie可以设置过期时间(默认会话结束就销毁)</li></ul><h4>配置项</h4><h5>expires</h5><p>expires用于设定cookie的有效时间,默认为会话结束后(浏览器窗口关闭)<br>expires必须是GMT格式的时间,可以通过new Date().toGMTString()或者 new Date().toUTCString()来获得</p><h5>domain,path</h5><p>domain和path共同确定了cookie的作用域,如果路径匹配成功,则会被添加到请求的头部中,如果没有设置,则会使用默认值<br>domain的默认值为设置该cookie的网页所在的域,path默认值为设置该cookie的网页所在的目录</p><h5>secure</h5><p>cookie通常使用http连接来传递数据,这种数据很容易被查看,所以cookie存储信息容易被窃取,当我们使用https等加密安全协议时,可以使用加密的数据传输cookie<br>secure选项用来设置cookie只会在安全的请求中才进行发送,但这样的cookie只有在传输过程中是加密的,存储到本地的cookie文件是不加密的,所以机密和敏感的信息不应该放在cookie中进行传输</p><h5>httpOnly</h5><p>cookie默认是可以通过js来进行操作的,但是如果我们不想js来操作cookie的话,可以通过设置httpOnly属性<br>设置过该属性后,客户端无法通过js代码来进行读取,写入,删除,修改等操作,这种类型的cookie只能由服务器端进行设置</p><h3>sessionstorage</h3><h3>localstorage</h3><h3>indexDB</h3><h2>讲解复述</h2><h2>纠错反思</h2><h2>检验成果</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;确立目标&lt;/h2&gt;&lt;p&gt;理解cookie,sessionstorage,localstorage,indexDB等浏览器存储数据方案的使用方法
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="browser storage" scheme="https://leo-wj910729.github.io/tags/browser-storage/"/>
    
  </entry>
  
  <entry>
    <title>new fucntion发生了什么</title>
    <link href="https://leo-wj910729.github.io/2019/02/26/new%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://leo-wj910729.github.io/2019/02/26/new一个函数时发生了什么/</id>
    <published>2019-02-26T02:59:27.000Z</published>
    <updated>2019-04-28T06:34:38.179Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parentClass</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">  <span class="keyword">this</span>.b = b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> parentClass(a,b)</span><br><span class="line">New(parentClass, a, b)</span><br><span class="line"><span class="comment">// 1.生成一个空对象</span></span><br><span class="line"><span class="comment">// 2.将该对象的原型指向到构造函数</span></span><br><span class="line"><span class="comment">// 3.函数的this属性赋值为该对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125; <span class="comment">// 生成一个空对象</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">constructor</span> = [].shift.call(arguments) // 得到构造函数</span><br><span class="line">  if (<span class="keyword">constructor</span>.prototype === null) &#123; <span class="comment">// 将对象的原型指向构造函数</span></span><br><span class="line">    obj.prototype = <span class="keyword">constructor</span>.prototype</span><br><span class="line">  &#125;</span><br><span class="line">  let ret = <span class="keyword">constructor</span>.apply(obj, [].slice.call(arguments)) // 获取构造函数的返回值 </span><br><span class="line">  if ((typeof ret === 'object' || typeof ret === 'function') &amp;&amp; ret !== null) &#123; <span class="comment">// 如果构造函数有返回值,且返回值为object,function类型的话,且不等于null,则返回构造函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则返回对象</span></span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>如何将类数组转化为数组类型</h3><ol><li>[].slice.call()</li><li>Array.from()</li></ol><p>Array.from使用时需要注意类数组的key值需要是数字</p><p>[].slice.call(arguments)将arguments转化为数组</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="function" scheme="https://leo-wj910729.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>跨域解决方案</title>
    <link href="https://leo-wj910729.github.io/2019/01/09/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://leo-wj910729.github.io/2019/01/09/跨域解决方案/</id>
    <published>2019-01-09T05:37:29.000Z</published>
    <updated>2019-04-28T06:35:29.127Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h2>跨域</h2><h3>原因</h3><p>浏览器出于安全考虑,有了同源原则.只要协议,域名,端口号三者有一个不同,都会被当做是不同域</p><h3>解决方案</h3><h4>JSONP</h4><p>利用script标签没有跨域限制的特性,通过把src的链接配置为接口的地址,并提供一个回调函数来接受数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsop</span>(<span class="params">url,jsonpCb, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCb] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h4>CORS</h4><p>CORS定义了必须访问跨域资源时,浏览器如何与服务器进行沟通<br>基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通,从而决定请求或响应是否成功<br>兼容性,不低于IE10<br>CORS通信的关键在服务器,服务器实现了CORS接口,就可以实现跨域通信,而浏览器端,无需做任何更改,由浏览器自动完成<br>服务器端对CORS的支持,主要是通过Access-Contril-Allow-Origin来进行,该属性用于标识哪些域名可以跨域访问,如果浏览器检测到域名匹配则可以进行跨域访问</p><h4>postMessage</h4><p>window.postMessage提供了一种受控机制来规避此限制,可以安全的实现跨源通信<br>当postMessage方法被调用时,会在页面脚本执行完毕后,会发送一个MessageEvent给目标窗口<br>MessageEvent含四个属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> messageCb = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> message = event.message <span class="comment">// 消息类型,消息名称</span></span><br><span class="line">  <span class="keyword">let</span> source = event.source <span class="comment">// 消息源window对象</span></span><br><span class="line">  <span class="keyword">let</span> origin = event.origin <span class="comment">// 消息来源地址</span></span><br><span class="line">  <span class="keyword">let</span> data = event.data <span class="comment">// 发送过来的消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, messageCb, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p></p><h4>Nginx反向代理</h4><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name www.xxx.com;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pase api.xxx.com;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;跨域&lt;/h2&gt;&lt;h3&gt;原因&lt;/h3&gt;&lt;p&gt;浏览器出于安全考虑,有了同源原则.只要协议,域名,端口号三者有一个不同,都会被当做是不同域&lt;/p&gt;&lt;
      
    
    </summary>
    
    
      <category term="browser" scheme="https://leo-wj910729.github.io/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>Node文件系统</title>
    <link href="https://leo-wj910729.github.io/2018/11/26/Node%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://leo-wj910729.github.io/2018/11/26/Node文件系统/</id>
    <published>2018-11-26T08:53:53.000Z</published>
    <updated>2019-04-28T06:34:22.991Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h3>fs模块</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h3&gt;fs模块&lt;/h3&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
      <category term="Node" scheme="https://leo-wj910729.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Git的基础操作指令</title>
    <link href="https://leo-wj910729.github.io/2018/10/13/git-base/"/>
    <id>https://leo-wj910729.github.io/2018/10/13/git-base/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2019-04-28T06:34:10.634Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h2>全局配置</h2><h3>Git操作</h3><ol><li><p>配置全局信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"henry"</span></span><br><span class="line">$ git config --global user.email henry@example.com</span><br><span class="line">$ git config --global <span class="built_in">alias</span>.&lt;<span class="built_in">alias</span>-name&gt; &lt;命令名&gt; // 设置别名 如 git ci 等价于 git commit</span><br></pre></td></tr></table></figure><p></p></li><li><p>初始化本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p></p></li><li><p>查询当前文件状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p></p></li><li><p>添加文件到git暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add 文件名</span><br><span class="line">$ git add . // 添加所有文件到暂存区</span><br></pre></td></tr></table></figure><p></p></li><li><p>提交暂存区文件到git本地仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'提交信息'</span></span><br><span class="line">$ git commit --amend // 重新提交</span><br></pre></td></tr></table></figure><p></p></li><li><p>撤销暂存区文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD 文件名</span><br></pre></td></tr></table></figure><p></p></li><li><p>查看远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">$ git remote -v // 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span><br></pre></td></tr></table></figure><p></p></li><li><p>添加远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;remote-name&gt; &lt;url&gt; // 添加一个新的远程Git仓库</span><br></pre></td></tr></table></figure><p></p></li><li><p>拉去远程仓库到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p></p></li><li><p>推送到远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p></p></li><li><p>修改远程仓库名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename &lt;remote-name&gt; &lt;new-remote-name&gt;</span><br></pre></td></tr></table></figure><p></p></li><li><p>删除远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm &lt;remote-name&gt;</span><br></pre></td></tr></table></figure><p></p></li><li><p>查看所有标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">$ git tag -l <span class="string">'搜索词'</span></span><br></pre></td></tr></table></figure><p></p></li><li><p>创建标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag  &lt;tag-name&gt; // 创建一个轻量标签</span><br><span class="line">$ git tag -a &lt;tag-name&gt; -m <span class="string">'存储在标签中的信息'</span> // -a 创建一个携带标签信息的标签 -m 标签信息</span><br><span class="line">$ git tag -a &lt;tag-name&gt; 提交的校验和（或部分校验和） // 给过去的提交打标签</span><br></pre></td></tr></table></figure><p></p></li><li><p>将标签推送到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;remote-name&gt; &lt;tag-name&gt; // 推送一个tag到远端</span><br><span class="line">$ git push &lt;remote-name&gt; --tags // 推送多个tag到远端</span><br></pre></td></tr></table></figure><p></p></li><li><p>删除标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d &lt;tag-name&gt; // 本地删除一个指定的tag</span><br><span class="line">$ git push &lt;remote-name&gt; :refs/tags/&lt;tag-name&gt; // 远端删除一个指定的tag</span><br></pre></td></tr></table></figure><p></p></li><li><p>检出标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag</span><br><span class="line">$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag</span><br></pre></td></tr></table></figure><p></p></li></ol><h3>分支操作</h3><ol><li><p>创建分支</p></li><li><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git brach -d</span><br></pre></td></tr></table></figure><p></p></li><li><p>查询分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;全局配置&lt;/h2&gt;&lt;h3&gt;Git操作&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;配置全局信息&lt;/p&gt;&lt;figure class=&quot;highlight ba
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="https://leo-wj910729.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>箭头函数与普通函数的区别</title>
    <link href="https://leo-wj910729.github.io/2018/08/14/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://leo-wj910729.github.io/2018/08/14/箭头函数与普通函数的区别/</id>
    <published>2018-08-14T03:08:17.000Z</published>
    <updated>2019-04-28T06:35:01.128Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h3>箭头函数</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrowFn = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数没有arguments属性</span></span><br><span class="line">  <span class="comment">// 箭头函数没有原型属性</span></span><br><span class="line">  <span class="comment">// 箭头函数不能当做generator函数,也不能使用yield关键字</span></span><br><span class="line">  <span class="comment">// 箭头函数作用域永远指向父级作用域,call,apply,bind都无法改变</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'箭头函数'</span>, <span class="built_in">arguments</span>) <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'箭头函数'</span>, args) <span class="comment">// 因为没有arguments属性,使用...扩展符来获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数不可以作为构造函数,因为其特性,this永远指向父级作用域,而构造函数的第一步就是将this赋值为生成的空对象</span></span><br><span class="line"><span class="keyword">new</span> arrowFn() <span class="comment">// Uncaught TypeError: FunConstructor is not a constructor</span></span><br></pre></td></tr></table></figure><p></p><h3>普通函数</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> normalFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'普通函数'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h3&gt;箭头函数&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="function" scheme="https://leo-wj910729.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>函数的节流</title>
    <link href="https://leo-wj910729.github.io/2018/08/13/throttle/"/>
    <id>https://leo-wj910729.github.io/2018/08/13/throttle/</id>
    <published>2018-08-12T16:00:00.000Z</published>
    <updated>2019-04-28T06:35:45.752Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h3>定义</h3><p>当持续触发事件时,在规定的时间内只触发一次,如果在规定的时间内再次触发事件,则不做任何操作</p><h3>应用场景</h3><p>监听是否滚动到底部,而触发上拉加载</p><h3>原理</h3><ol><li>时间戳形式,通过闭包保存上一次的时间戳,将其与事件触发时的时间戳进行比较,如果差值大于设定的时间,则调用事件,并记录时间戳,否则不进行任何操作</li><li>定时器形式,通过闭包保存定时器,事件触发时,如果定时器为null,则执行cb,并设置新的定时器</li></ol><h3>实现方法</h3><ol><li><p>时间戳形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">cb, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prevTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    <span class="keyword">if</span> (now &gt; prevTime + delay) &#123;</span><br><span class="line">      fun.apply(that, _args)</span><br><span class="line">      prevTime = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>定时器形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">cb, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">        cb.apply(that, _args)</span><br><span class="line">      &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li><li><p>时间戳加定时器的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">cb, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> prevTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">let</span> tag = delay - (now - prevTime)</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    <span class="keyword">if</span> (tag &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      cb.apply(that, delay)</span><br><span class="line">      prevTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cb.apply(that, delay)</span><br><span class="line">      &#125;, ta)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h3&gt;定义&lt;/h3&gt;&lt;p&gt;当持续触发事件时,在规定的时间内只触发一次,如果在规定的时间内再次触发事件,则不做任何操作&lt;/p&gt;&lt;h3&gt;应用场景&lt;/h3
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="function" scheme="https://leo-wj910729.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>函数的防抖</title>
    <link href="https://leo-wj910729.github.io/2018/07/06/dounce/"/>
    <id>https://leo-wj910729.github.io/2018/07/06/dounce/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2019-04-28T06:33:34.709Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h3>定义</h3><p>触发时间后的一段时间内,该事件的回调函数仅会触发一次,如果在规定时间内再次触发该事件,则重新开始计算时间 游戏理解: 法师读条法术,进度条未读完再次释放则会打断上次施法</p><h3>应用场景</h3><ol><li>用户连续操作导致事件频发触发回调</li><li>用户只关系操作之后的结果(滚动条啊,搜索输入啊,这种)</li></ol><h3>原理</h3><p>通过定时器将回调函数进行延时,在规定时间内继续回调,发现存在之前的定时器时,清空该定时器并重新设置新的定时器</p><h3>实现方法</h3><ol><li><p>非立即执行版本: 事件触发=&gt; 延时=&gt; 执行回调函数 在延时中触发事件,则会重新进行延时,延时结束后执行回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">cb, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    clearTimeout(cb.timer)</span><br><span class="line">    cb.timer = setTimout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      cb.call(that, _args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'这是一个回调函数'</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> debounceFn = debounce(cb)</span><br><span class="line"><span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'test-input'</span>)</span><br><span class="line">input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  debounceFn(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p></li><li><p>立即执行版本: 事件触发=&gt; 执行回调函数=&gt; 延时 在延时中触发事件,则会重新进行延时,延时结束,并不会执行回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">cb, immediate = true, delay = <span class="number">16</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> _args = args</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!timer) cb.apply(that, args)</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cb.apply(that, args)</span><br><span class="line">      &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></li></ol><p>// 防抖就是在一段时间内如果没有操作,则执行函数,如果有操作,则清除定时器重新执行 // 节流就是在一段时间内只会触发一次函数操作</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h3&gt;定义&lt;/h3&gt;&lt;p&gt;触发时间后的一段时间内,该事件的回调函数仅会触发一次,如果在规定时间内再次触发该事件,则重新开始计算时间 游戏理解: 法师
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="function" scheme="https://leo-wj910729.github.io/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="https://leo-wj910729.github.io/2018/06/23/GarbageCollection/"/>
    <id>https://leo-wj910729.github.io/2018/06/23/GarbageCollection/</id>
    <published>2018-06-22T16:00:00.000Z</published>
    <updated>2019-04-28T06:33:08.785Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h1>垃圾回收机制</h1><p><strong>javascript</strong>有内置的垃圾回收机制GC,执行环境在管理代码执行过程中使用的内存,内存的分配和回收全都由js引擎来管理</p><h2>内存生命周期</h2><ol><li>内存分配阶段: 声明变量,函数,对象并执行时,系统会自动为其分配内存</li><li>内存使用阶段: 使用变量,函数时</li><li>内存回收阶段: 变量,函数被使用完毕,由GC机制回收</li></ol><h2>垃圾回收机制的策略</h2><h3>标记清除法: mark-and-sweep</h3><p><strong>算法:</strong></p><ol><li>标记阶段: GC从根开始遍历,凡是可以到达根的对象,都是仍需要使用的对象,被标记</li><li>清除阶段: GC会对堆内存从头到尾进行线性遍历,发现对象没有被标记则将其占用的内存回收,标记了的对象被去除标记</li></ol><p><strong>缺陷</strong></p><ol><li>不能从根对象查询到的对象都会被清除</li><li>GC后会产生大量的内存碎片,因为对象需要连续的内存单位,可能会导致内存碎片持续未被使用,直到内存溢出</li></ol><hr><h3>引用计数法</h3><p><strong>算法:</strong><br>对象是否未被其他对象引用</p><p><strong>缺陷:</strong><br>无法处理循环引用,创建两个对象,互相引用,则这两个对象永远无法被垃圾回收,从而导致内存溢出</p><hr><h3>V8垃圾回收算法</h3><p>chrome的v8引擎采用了分代回收策略,将内存对象分为临时对象和持久对象<br>临时对象和持久对象的回收机制并不相同<br>因为GC会导致js线程暂停执行,一次较长的GC可能会持续1s以上的时间,所以通过持续回收临时对象来减少GC的执行时间</p><hr><h3>V8的内存限制</h3><p>在node中javascript可使用的内存有限制</p><blockquote><ol><li>64位系统下约1.4GB,临时对象存储空间约32MB</li><li>32位系统下约0.7GB,临时对象存储空间约16MB</li></ol></blockquote><h4>临时对象</h4><p>临时对象的存储空间将会被均分为两块,只有一块处于使用状态,其被称为FROM空间,另一块则闲置,被称为TO空间 GC时,将FROM空间中的临时对象中的存活对象进行标记,GC结束后将被标记对象复制到TO空间中,将FROM空间的内存清空,此时FROM空间与TO空间角色互换,如此循环<br>**缺陷:**减少了空间的使用,换来了时间上的节省<br>**优点:**极其适合临时对象的垃圾回收,因为临时对象生命周期短,适合该算法</p><h5>晋升机制</h5><p>当一个对象经过多次复制后依然存在,其就会被标记为持久对象,被移动至持久对象存储空间中</p><h5>晋升条件</h5><ol><li>对象经历过临时存储空间的GC</li><li>临时存储空间中的TO空间被占据25%以上</li></ol><h4>持久对象</h4><p>持久对象的存储空间较大,存储的对象较多,使用临时对象的那种GC算法牺牲的空间太大,而且持久对象的生命周期较长<br>持久对象的GC算法为mark-and-sweep,即标记-清除,标记非活跃对象,清除非活跃对象 但是mark-and-sweep会导致内存不连续,产生大量的内存碎片,导致内存溢出的可能性 为了解决上述问题引入了一种新的算法Mark-compact,即标记-排列整理,在标记后,将活跃对象往一端移动,移动完成后,清除边界外的内存,但该种算法的执行速度较慢,所以仅在临时对象晋升后的内存分配时使用</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h1&gt;垃圾回收机制&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;javascript&lt;/strong&gt;有内置的垃圾回收机制GC,执行环境在管理代码执行过程中使用的
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="https://leo-wj910729.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://leo-wj910729.github.io/2018/06/21/algorithm-shellsort/"/>
    <id>https://leo-wj910729.github.io/2018/06/21/algorithm-shellsort/</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2019-04-28T06:32:41.146Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><hr><h2>算法介绍</h2><h3>1.1 算法描述</h3><p>希尔排序是建立在插入排序上的改进排序方法,对排序情况较好的序列排序时,能够达到较好的排序效率</p><h3>1.2 算法步骤</h3><ol><li>选择一个增量序列,t1, t2, ....,tj,tk 依次减少,最小为1</li><li>按照增量序列的个数,对序列进行k次排序</li><li>每次排序根据对应的增量ti,将待排序列分割成若干长度为m的子序列,分别对各子表进行直接插入排序.</li></ol><h3>1.3 算法实现</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">funtion shellSort (arr) &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length</span><br><span class="line">  <span class="keyword">let</span> temp</span><br><span class="line">  <span class="keyword">let</span> gap = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">2</span>) &#123;</span><br><span class="line">    gap = gap * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (;gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      temp = arr[i] <span class="comment">// 按照步进值取出对应的分块数据 arr[2]和arr[0]配对 依次类推   </span></span><br><span class="line">      <span class="comment">// 该gap值下所分的组进行插值排序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i-gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        <span class="comment">// arr[j] &gt; arr[i] 前值大于后值</span></span><br><span class="line">        arr[j+gap] = arr[j] <span class="comment">// 将前值赋值给后值</span></span><br><span class="line">      &#125;</span><br><span class="line">      arr[j+gap] = temp <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;h2&gt;算法介绍&lt;/h2&gt;&lt;h3&gt;1.1 算法描述&lt;/h3&gt;&lt;p&gt;希尔排序是建立在插入排序上的改进排序方法,对排序情况较好的序列排序时,能够达
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="algorithm" scheme="https://leo-wj910729.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://leo-wj910729.github.io/2018/05/20/algorithm-quicksort/"/>
    <id>https://leo-wj910729.github.io/2018/05/20/algorithm-quicksort/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2019-04-28T06:32:49.806Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><hr><h2>算法介绍</h2><h3>1.1 算法描述</h3><p>快速排序因为时间复杂度较低,且其核心思想分治法实用性强,算法难度不高,使其流行度较高</p><h3>1.2 算法步骤</h3><ol><li>从数组中取出一个数作为基数</li><li>对数组进行遍历,将大于该数的数放在基数的右边,小于该数的放在基数的左边</li><li>对左侧和右侧的数组继续进行上述操作,直至左右侧只有一位数</li></ol><h3>1.3 算法实现</h3><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">funtion quickSort (arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.isArray) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span> []</span><br><span class="line">  <span class="keyword">let</span> baseIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> baseNumber = arr.splice(baseIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left = []</span><br><span class="line">  <span class="keyword">let</span> right = []</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item &lt; baseNumber) left.push(item)</span><br><span class="line">    <span class="keyword">else</span> right.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat(baseNumber,quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;h2&gt;算法介绍&lt;/h2&gt;&lt;h3&gt;1.1 算法描述&lt;/h3&gt;&lt;p&gt;快速排序因为时间复杂度较低,且其核心思想分治法实用性强,算法难度不高,使其流
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="algorithm" scheme="https://leo-wj910729.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>docker基础知识</title>
    <link href="https://leo-wj910729.github.io/2018/03/26/dcoker-base/"/>
    <id>https://leo-wj910729.github.io/2018/03/26/dcoker-base/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2019-04-24T03:00:58.466Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><hr><h3>docker的核心</h3><hr><h4>镜像</h4><p>可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。  每次对镜像的修改都会产生一个新的镜像层,该镜像层基于修改前的镜像。  镜像内存储的是不可变的文件。</p><h4>容器</h4><p>用于隔离虚拟环境的基础设施。  如果将镜像比作类,那么容器就是类的实例  容器是活的空间,内部文件可变</p><h4>网络</h4><p>利用一些技术,DOcker能够在容器中营造出独立的域名解析环境,这意味着我们不需要付出任何代价就可以创造出同一环境的容器  两台物理机上的docker容器,可以加入同一个虚拟网络中</p><h4>数据卷</h4><p>可以挂载在宿主操作系统中的目录上  容器内建立独立的目录持久存放数据  容器间共享</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;h3&gt;docker的核心&lt;/h3&gt;&lt;hr&gt;&lt;h4&gt;镜像&lt;/h4&gt;&lt;p&gt;可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容
      
    
    </summary>
    
    
      <category term="docker" scheme="https://leo-wj910729.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker-volume 数据卷</title>
    <link href="https://leo-wj910729.github.io/2018/03/21/docker-volume/"/>
    <id>https://leo-wj910729.github.io/2018/03/21/docker-volume/</id>
    <published>2018-03-20T16:00:00.000Z</published>
    <updated>2019-04-24T03:00:50.962Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><h2>数据卷的几种形态</h2><h3>不使用数据卷</h3><blockquote><p>默认情况下docker容器不使用任何volume,此时,容器的数据被保存在容器中,当容器被删除时,数据也被删除,我们可以使用docker commit 将该容器持久化为一个镜像</p></blockquote><h3>Data volume (数据卷)</h3><ol><li><p>使用&quot;-v 容器内目录&quot;形式,将本地一个_data目录挂载为容器内的webapp目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P --name web -v /webapp training/webapp python app.py</span><br><span class="line">$ docker inspect </span><br><span class="line">$ <span class="string">"Mounts"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="string">"Name"</span>: <span class="string">"f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b"</span>,</span><br><span class="line">      <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b/_data"</span>,</span><br><span class="line">      <span class="string">"Destination"</span>: <span class="string">"/webapp"</span>,</span><br><span class="line">      <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">      <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p></li><li><p>使用-v挂载主机上的一个文件到容器内的一个文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -v ~/.bash_history:/root/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p></p></li></ol><h3>Data container (容器数据卷)</h3><p>在容器间共享数据,可以使用容器来进行数据的存储,这样的容器不会跑应用,而仅仅是挂载一个数据卷</p><blockquote><p><strong>缺点:</strong> 容器可以被删除 <strong>优点:</strong> 可以持续重复的使用数据</p></blockquote><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ 创建一个数据卷容器</span><br><span class="line">$ docker create -v /dbdata --name dbstore training/webapp  /bin/<span class="literal">true</span></span><br><span class="line">$ 运行数据卷容器</span><br><span class="line">$ docker run -d -P --name web3 --volumes-from dbstore training/webapp python app.py</span><br><span class="line">$ docker inspect</span><br><span class="line">$ <span class="string">"Mounts"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="string">"Name"</span>: <span class="string">"5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330"</span>,</span><br><span class="line">      <span class="string">"Source"</span>: <span class="string">"/var/lib/docker/volumes/5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330/_data"</span>,</span><br><span class="line">      <span class="string">"Destination"</span>: <span class="string">"/dbdata"</span>,</span><br><span class="line">      <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span><br><span class="line">      <span class="string">"Mode"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="string">"RW"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><h3>使用docker volume命令</h3><ol><li><p>创建数据卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create --name 数据卷名</span><br><span class="line">$ docker volume inspect 数据卷名</span><br></pre></td></tr></table></figure><p></p></li><li><p>使用数据卷</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P --name 容器名 -v 数据卷名:/volume training/webapp python app.p</span><br></pre></td></tr></table></figure><p></p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;h2&gt;数据卷的几种形态&lt;/h2&gt;&lt;h3&gt;不使用数据卷&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;默认情况下docker容器不使用任何volume,此时,
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从创建到发布-hexo的文章编写发布流程</title>
    <link href="https://leo-wj910729.github.io/2018/02/11/hexo-deploy/"/>
    <id>https://leo-wj910729.github.io/2018/02/11/hexo-deploy/</id>
    <published>2018-02-10T16:00:00.000Z</published>
    <updated>2019-04-24T03:01:10.795Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --><p>这是一段描述</p><p>&lt;!-- more --&gt;</p><h2>快速开始</h2><h3>创建一篇文章</h3><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"一篇新的文章"</span></span><br></pre></td></tr></table></figure><p></p><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3>运行hexo服务</h3><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p></p><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3>生成静态文件</h3><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p></p><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3>发布静态博客</h3><p></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p></p><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Apr 28 2019 14:36:14 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;这是一段描述&lt;/p&gt;&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;&lt;h2&gt;快速开始&lt;/h2&gt;&lt;h3&gt;创建一篇文章&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;
      
    
    </summary>
    
      <category term="学习" scheme="https://leo-wj910729.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="hexo" scheme="https://leo-wj910729.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
