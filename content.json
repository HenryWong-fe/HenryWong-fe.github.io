{"meta":{"title":"林中小屋","subtitle":"宁静致远","description":null,"author":"Henry Wang","url":"https://leo-wj910729.github.io","root":"/"},"pages":[{"title":"Repositories","date":"2019-04-21T06:20:24.372Z","updated":"2019-04-21T06:20:24.372Z","comments":false,"path":"repository/index.html","permalink":"https://leo-wj910729.github.io/repository/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-04-21T06:20:50.859Z","updated":"2019-04-21T06:20:50.859Z","comments":false,"path":"/404.html","permalink":"https://leo-wj910729.github.io//404.html","excerpt":"","text":"&lt;script type=&quot;text/javascript&quot; src=&quot;//www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;&lt;%- config.url %&gt;&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt;"},{"title":"分类","date":"2019-04-21T06:20:23.551Z","updated":"2019-04-21T06:20:23.550Z","comments":false,"path":"categories/index.html","permalink":"https://leo-wj910729.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-21T06:19:30.914Z","updated":"2019-04-21T06:19:30.914Z","comments":false,"path":"tags/index.html","permalink":"https://leo-wj910729.github.io/tags/index.html","excerpt":"","text":""},{"title":"Henry的小简历","date":"2019-04-21T04:47:25.000Z","updated":"2019-04-21T11:54:49.641Z","comments":true,"path":"about/index.html","permalink":"https://leo-wj910729.github.io/about/index.html","excerpt":"","text":"工作经历北京源石云科技有限公司上海分公司 2018.3 - 至今工作内容 负责App版本迭代,节日活动,内部管理后台,项目公用库维护,项目脚手架编写及维护,代码风格制定,分支代码合并及管理 项目经验 项目脚手架,微博内嵌商城,金币系统,大牌闪降,砍价,零元拼团,数码产品回收,拼团,各类活动页上海得仕网络科技有限公司 2017.3 - 2018.2工作内容 负责得仕彩票web端页面开发,利是利员工福利App混合开发,负责制定代码规范,代码合并及管理 项目经验 得仕彩票web端页面,利是利员工福利平台App页面开发杭州引力科技有限公司 2015.5 - 2017.2工作内容 负责公司后台页面开发,公司外包业务开发 项目经验 公司外包页面"}],"posts":[{"title":"浏览器滚动穿透问题.md","slug":"浏览器滚动穿透问题-md","date":"2019-06-08T01:44:05.000Z","updated":"2019-06-08T02:13:08.704Z","comments":true,"path":"2019/06/08/浏览器滚动穿透问题-md/","link":"","permalink":"https://leo-wj910729.github.io/2019/06/08/浏览器滚动穿透问题-md/","excerpt":"","text":"滚穿是什么当我们用fixed定位元素做蒙层,引导用户进行操作时,用户对弹层的滑动操作会导致蒙层下的页面跟随滚动模态框的组成 遮罩层 模态框如何解决滚穿禁止遮罩层滚动监听用户手势滑动动作,当用户滑动至弹窗上层边界和下层边界时,阻止其touch事件123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div class=\"mask\" @touchmove.stop&gt; &lt;div class=\"model\" @touchmove=\"touchMove\" id=\"Model\" @touchstart=\"touchStart\"&gt; &lt;span class=\"content\" v-for=\"i in 20\"&gt;这是一段文字&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; ... data() &#123; return &#123; startY: 0 &#125; &#125;, methods: &#123; touchmoveForbidden(e) &#123; e.preventDefault() &#125;, touchStart(e) &#123; this.startY = e.targetTouches[0].clientY &#125;, touchMove(e)&#123; let target = document.getElementById('Model') let offsetHeight = target.offsetHeight let scrollHeight = target.scrollHeight; let changedTouches = e.changedTouches; let scrollTop = target.scrollTop; if (changedTouches.length &gt; 0) &#123; let touch = changedTouches[0] || &#123;&#125;; let moveY = touch.clientY; if (moveY &gt; this.firstY &amp;&amp; scrollTop === 0) &#123; // 滑动到弹窗顶部临界条件 e.preventDefault() return false &#125; else if (moveY &lt; this.firstY &amp;&amp; scrollTop + offsetHeight &gt;= scrollHeight) &#123; // 滑动到底部临界条件 e.preventDefault() return false &#125; &#125; &#125; &#125; &#125;&lt;/script&gt;复习一下相关知识点offsetHeight 元素自身的高度(含border,padding,滚动条高度)clientHeight 元素自身的高度(仅含padding)scrollHeight 元素不滚动时,scrollHeight = clientHeight,元素滚动时scrollHeight = scrollTop + clientHeightscrollTop 元素滚动时,已滚动到元素顶部以上的距离offsetTop 元素距离最近一级定位父元素顶部的距离","categories":[],"tags":[{"name":"Bug","slug":"Bug","permalink":"https://leo-wj910729.github.io/tags/Bug/"}]},{"title":"手撕api系列","slug":"手撕系列","date":"2019-05-25T06:57:58.000Z","updated":"2019-06-08T01:45:33.037Z","comments":true,"path":"2019/05/25/手撕系列/","link":"","permalink":"https://leo-wj910729.github.io/2019/05/25/手撕系列/","excerpt":"","text":"实现bind函数12345678910111213Function.prototype.bind = Function.prototype.bind || function (context) &#123; let me = this let F = function () &#123;&#125; let args = Array.prototype.slice.call(arguments, 1) F.prototype = me.prototype let bound = function () &#123; let fnArgs = Array.prototype.slice.call(arguments) let finalArgs = args.concat(fnArgs) return me.apply(this instanceof F ? this : context || this, finalArgs) &#125; bound.prototype = new F() // bound生成的实例使用instanceof 会指向 bind的 this return bound&#125;实现call函数12345Function.prototype.call = Function.prototype.call || function (context) &#123; let args = Array.prototype.slice(arguments, 1) let me = this return me()&#125;实现map函数使用for循环实现map12345678910Function.prototype.map = Function.prototype.map || function (fn, context) &#123; if (!(this instanceof Array)) throw new TypeError(me + 'is not a Array') var arr = Array.prototype.slice.call(me) var mapedArr = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (!arr.hasOwnProperty[i]) continue mapedArr.push(fn.call(context, arr[i], i, this)) &#125; return mapedArr&#125;使用reduce实现map1234567Function.prototype.map = Function.prototype.map || function (fn, context) &#123; if (!(this instanceof Array)) throw new TypeError(me + 'is not a Array') var arr = Array.prototype.slice.call(me) return arr.reduce((pre, cur, index) =&gt; &#123; return [...pre, fn.call(context, cur, index, this)] &#125;, [])&#125;实现reduce函数reduce函数参数描述处理函数 function(total,currentValue, index,arr)必需。用于执行每个数组元素的函数initialValue可选。传递给函数的初始值处理函数参数描述total必须,初始值或计算结束后的返回值currentValue必须,当前元素currentIndex可选,当前元素索引arr可选,当前元素所属的数组对象1234567891011Array.prototype.reduce = Array.prototype.reduce || function (fn, initValue) &#123; let arr = this if (!(arr instanceof Array)) throw new TypeError(arr + 'is not a array') if (!arr.length) return 0 let base = typeof initValue === 'undefined' ? arr[0] : initValue let initIndex = typeof initValue === 'undefined' ? 1 : 0 arr.slice(initIndex).forEach((item, index) =&gt; &#123; base = fn(base, item, initIndex + index, arr) &#125;) return base&#125;实现some函数some函数参数描述处理函数 function(total,currentValue, index,arr)必需。用于执行每个数组元素的函数thisValue可选。对象作为该执行回调时使用，传递给函数，用作 &quot;this&quot; 的值处理函数参数描述currentValue必须,当前元素currentIndex可选,当前元素索引arr可选,当前元素所属的数组对象12345678910111213Array.prototype.some = Array.prototype.some || function (fn, context) &#123; if (!(this instanceof Array)) throw new TypeError(this + 'is not a Array') if (!this.length) return [] var tag = false var arr = Array.prototype.slice.call(this) var len = arr.length for (var i =0; i&lt; arr.length; i++) &#123; if (!arr.hasOwnProperty(i)) continue tag = fn.call(context, item, index, arr)) if (tag) return true &#125; return false&#125;实现filter函数123456789Array.prototype.filter = Array.prototype.filter || function (fn, context) &#123; if (!(this instanceof Array)) throw new TypeError(this + 'is not a Array') if (!this.length) return [] let ret = [] this.forEach((item, index) =&gt; &#123; fn.call(context, item, index, this) &amp;&amp; ret.push(result) &#125;) return ret&#125;实现curry函数123456funciton curry (...fns) &#123; return function (...args) &#123; fns.forEach(fn =&gt; fn.call(null, args)) &#125;&#125;curry(fn1, fn2, fn3)(1,2,3)实现new123456function new (...args) &#123; let constructor = args.shift() let obj = Object.create(construtor) let result = constructor.apply(obj, args) return (typeof result === 'Object' &amp;&amp; result !== 'null') ? result : obj&#125;函数节流函数节流=&gt; 规定时间内多次触发,只会有一次123456789101112function throttle (fn, delay) &#123; let _start = Date.now() return function () &#123; let _now = Date.now() let args = Array.prototype.slice(arguments) let context = this if (_now - _start &gt;= delay) &#123; fn.apply(context, args) nowTime = Date.now() &#125; &#125;&#125;函数防抖函数防抖=&gt; 规定时间内多次触发,在规定时间内多次触发,会取消上一次触发的结果12345678910function debounce (fn, delay) &#123; let timer = null return function () &#123; timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; let context = this fn.apply(context, Array.prototype.slice(arguments)) &#125;, delay) &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://leo-wj910729.github.io/tags/es6/"}]},{"title":"vue项目格式化","slug":"vue项目格式化","date":"2019-05-15T06:57:58.000Z","updated":"2019-06-08T01:44:33.935Z","comments":true,"path":"2019/05/15/vue项目格式化/","link":"","permalink":"https://leo-wj910729.github.io/2019/05/15/vue项目格式化/","excerpt":"","text":"vscode中开发vue项目,用到的几个格式化代码的工具vscode自带的格式化 vetur 对vue后缀的文件进行格式化,分别格式化template style script,可配置相应的格式化工具 vue-style-beautify 因prettier会自动将style中的大写px格式化为小写的px,使用其可以避免该问题,内置对样式属性的排序功能vetur的相关配置对vue文件的代码做高亮展示1234567&#123; \"vetur.format.defaultFormatter.scss\": \"none\", \"vetur.format.defaultFormatter.postcss\": \"none\", \"vetur.format.defaultFormatter.css\": \"none\", \"vetur.format.options.useTabs\": true, \"vueStyle.formatOnSave\": true,&#125;vue-style-beautify这是一个专门为vue文件样式格式化的插件,特点是会按照csscomb的规则对css样式进行排序 优点是格式化时不会将大写的PX转译为小写的px 其缺点是会将文件全部展开","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://leo-wj910729.github.io/tags/vue/"}]},{"title":"NodeJs的path模块","slug":"NodeJs的path模块","date":"2019-04-30T05:36:39.000Z","updated":"2019-04-30T06:51:56.074Z","comments":true,"path":"2019/04/30/NodeJs的path模块/","link":"","permalink":"https://leo-wj910729.github.io/2019/04/30/NodeJs的path模块/","excerpt":"","text":"方法path.normalize(路径) 规范化路径path.join(path1,path2,path3,path4....) 用于连接路径,该方法会正确使用系统路径分隔符path.reslove([from...],to) 将to参数解析为绝对路径,给定的路径的序列是从右向左被处理的,后面的path依次解析,直到构建出一个完成的path路径path.isAbsolute(path) 判断路径是否为绝对路径path.relative(from, to) 返回从from 到 to的相对路径path.dirname(path) 返回路径中代表文件夹的部分path.basename(path) 返回路径中的最后部分path.parse(pathString) 返回路径字符串的对象path.format(pathObject) 从对象中返回路径字符串","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://leo-wj910729.github.io/tags/Node/"}]},{"title":"为何使用void0代替undefined","slug":"为何使用void0代替undefined","date":"2019-04-29T06:39:20.000Z","updated":"2019-04-29T06:44:19.733Z","comments":true,"path":"2019/04/29/为何使用void0代替undefined/","link":"","permalink":"https://leo-wj910729.github.io/2019/04/29/为何使用void0代替undefined/","excerpt":"","text":"原因在javascript中undefined是变量而非关键字,这导致了使用undefined作为变量时,是可以随意赋值的,其值可变12var undefined = 1console.log(undefined) // 1实际情况在IE8以上的浏览器中,全局作用域下undefined值不可变12var undefined = 1console.log(undefined) // undefined在IE8中的浏览器中,全局作用域下undefined值可以更改12var undefined = 1console.log(undefined) // 1在IE8以上的浏览器中,块级作用域下的undefined值可以更改1234(function () &#123; var undefined = 2 console.log(undefined); //2 &#125;)()","categories":[],"tags":[]},{"title":"ES6之let与const","slug":"ES6之let与const","date":"2019-04-29T06:02:45.000Z","updated":"2019-04-29T06:16:59.584Z","comments":true,"path":"2019/04/29/ES6之let与const/","link":"","permalink":"https://leo-wj910729.github.io/2019/04/29/ES6之let与const/","excerpt":"","text":"let用于声明变量,会在当前作用域下形成块级作用域,其声明的变量不在受外部作用域影响特性使用let声明的变量,不会出现变量提升,意味着在声明前调用会报错用法1234for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;注意事项在未声明前调用变量会报错1234console.log(b) // 报错 未定义let b b = 1let a = a //报错const用于声明常量特性声明时必须初始化,也就是赋值,初始化后不可修改,声明前调用变量会报错用法1234console.log(a) // 报错 未定义const b // 报错 声明时就必须初始化,且不可在修改const a = 1a = 2 // 报错 不可以修改注意事项const声明的对象是可以修改属性的,造成这一的原因主要是因为声明的对象变量中保存的是对象的内存指针,修改对象本身的属性并不会引起对象指针的变化1234const a = &#123;b: 1&#125;a.b = 2 console.log(a.b) // 2a = &#123;&#125; // 报错 重新赋值对象会导致指针变化,所以会报错","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"https://leo-wj910729.github.io/tags/es6/"}]},{"title":"如何解决canvas绘制时出现的闪屏问题","slug":"如何解决canvas绘制时出现的闪屏问题","date":"2019-04-28T12:38:01.000Z","updated":"2019-04-28T13:07:36.699Z","comments":true,"path":"2019/04/28/如何解决canvas绘制时出现的闪屏问题/","link":"","permalink":"https://leo-wj910729.github.io/2019/04/28/如何解决canvas绘制时出现的闪屏问题/","excerpt":"","text":"问题代码12345678function refreshCanvas () &#123; const canvas = document.getElementById('canvas') const ctx = canvas.getContext('2d') // 清除画布 ctx.clearRect(0,0, canvas.width, canvas.height) // 重新绘制 ctx.drawImage(bg, 0, 0)&#125;问题分析canvas在清除画布时,如果绘制时间过长,则会导致出现闪屏的问题解决方案1234567891011121314function refreshCanvas () &#123; const canvas = document.getElementById('canvas') const tempcanvas = document.getElementById('canvas') const ctx = canvas.getContext('2d') const tempctx = tempcanvas.getContext('2d') tempctx.width = window.screen.width tempctx.height = window.screen.height // 缓存canvas绘制 tempCtx.drawImage(bg,0,0); // 背景 // 目标canvas清除画布 ctx.clearRect(0,0, canvas.width, canvas.height) // 目标canvas重新绘制 ctx.drawImage(tempcanvas, 0, 0)&#125;","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://leo-wj910729.github.io/tags/canvas/"}]},{"title":"浏览器的回流与重绘","slug":"浏览器的回流与重绘","date":"2019-04-28T06:45:57.000Z","updated":"2019-06-08T01:22:40.819Z","comments":true,"path":"2019/04/28/浏览器的回流与重绘/","link":"","permalink":"https://leo-wj910729.github.io/2019/04/28/浏览器的回流与重绘/","excerpt":"","text":"浏览器的渲染机制渲染步骤读取字符流,通过状态机,将字符转化为DOM节点,并构成树形结构处理CSS,构建CSSOM树将DOM树,与CSSOM树结合构建出渲染树调用GPU绘制,合成图层注意事项构建CSSOM树时,会阻塞渲染,直至CSSOM树构建完成,所以深层的嵌套结构会导致更长的构建时间,保持层级的扁平有助于提升页面性能越是具体的CSS选择器,执行速度越慢js代码会阻止DOM树的构建,如果想拥有更快的首屏加载速度,则应将脚本文件,放在body标签后Load和DOMContentLoaded的区别Load事件表明js,css,dom,图片均加载完毕DOMContentLoaded事件表明html被完全加载和解析,可以进行对dom节点的操作图层正常的文档流是一个图层,一些特别的属性可以生成一个新的图层,不同图层的渲染互不影响如果想对DOM节点进行持续的操作,最好将DOM节点生成一个新的图层过多的图层依然会引起页面性能的下降以下几个属性和标签会产生新的图层transfrom: translateZ(0) transfrom: translate3d()will-changevideo,iframe标签position: fixedopacity回流与重绘概念回流与重绘和Event loop的关系如何触发回流与重绘如何减少回流与重绘","categories":[],"tags":[{"name":"browser","slug":"browser","permalink":"https://leo-wj910729.github.io/tags/browser/"}]},{"title":"浏览器存储方案","slug":"浏览器存储方案","date":"2019-04-26T07:08:13.000Z","updated":"2019-04-28T07:14:00.921Z","comments":true,"path":"2019/04/26/浏览器存储方案/","link":"","permalink":"https://leo-wj910729.github.io/2019/04/26/浏览器存储方案/","excerpt":"","text":"确立目标理解cookie,sessionstorage,localstorage,indexDB等浏览器存储数据方案的使用方法,优缺点学习理解cookie特征不同浏览器存储cookie的位置不同,所以不能通用不同域下的cookie是独立的我们能够操作的cookie,是在当前域,和当前域的子域中一个域下可存储的cookie有限(20个左右)存放大小也有限制(4kb)cookie可以设置过期时间(默认会话结束就销毁)配置项expiresexpires用于设定cookie的有效时间,默认为会话结束后(浏览器窗口关闭)expires必须是GMT格式的时间,可以通过new Date().toGMTString()或者 new Date().toUTCString()来获得domain,pathdomain和path共同确定了cookie的作用域,如果路径匹配成功,则会被添加到请求的头部中,如果没有设置,则会使用默认值domain的默认值为设置该cookie的网页所在的域,path默认值为设置该cookie的网页所在的目录securecookie通常使用http连接来传递数据,这种数据很容易被查看,所以cookie存储信息容易被窃取,当我们使用https等加密安全协议时,可以使用加密的数据传输cookiesecure选项用来设置cookie只会在安全的请求中才进行发送,但这样的cookie只有在传输过程中是加密的,存储到本地的cookie文件是不加密的,所以机密和敏感的信息不应该放在cookie中进行传输httpOnlycookie默认是可以通过js来进行操作的,但是如果我们不想js来操作cookie的话,可以通过设置httpOnly属性设置过该属性后,客户端无法通过js代码来进行读取,写入,删除,修改等操作,这种类型的cookie只能由服务器端进行设置sessionstorage特点数据在相同协议,端口,域名,窗口下,可以访问,且会话窗口关闭则数据被清除12window.sessionStorage.setItem(key, value) // value必须是字符串类型window.sessionStorage.getItem(key)localstorage特点 数据持久化存储,相同协议,端口,域名下就可以访问并操作数据","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"browser storage","slug":"browser-storage","permalink":"https://leo-wj910729.github.io/tags/browser-storage/"}]},{"title":"new fucntion发生了什么","slug":"new一个函数时发生了什么","date":"2019-02-26T02:59:27.000Z","updated":"2019-04-28T06:34:38.179Z","comments":true,"path":"2019/02/26/new一个函数时发生了什么/","link":"","permalink":"https://leo-wj910729.github.io/2019/02/26/new一个函数时发生了什么/","excerpt":"","text":"1234567891011121314151617181920212223function parentClass (a,b) &#123; this.a = a this.b = b&#125;new parentClass(a,b)New(parentClass, a, b)// 1.生成一个空对象// 2.将该对象的原型指向到构造函数// 3.函数的this属性赋值为该对象function New () &#123; let obj = &#123;&#125; // 生成一个空对象 let constructor = [].shift.call(arguments) // 得到构造函数 if (constructor.prototype === null) &#123; // 将对象的原型指向构造函数 obj.prototype = constructor.prototype &#125; let ret = constructor.apply(obj, [].slice.call(arguments)) // 获取构造函数的返回值 if ((typeof ret === 'object' || typeof ret === 'function') &amp;&amp; ret !== null) &#123; // 如果构造函数有返回值,且返回值为object,function类型的话,且不等于null,则返回构造函数的返回值 return ret &#125; // 否则返回对象 return obj&#125;如何将类数组转化为数组类型[].slice.call()Array.from()Array.from使用时需要注意类数组的key值需要是数字[].slice.call(arguments)将arguments转化为数组","categories":[],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"跨域解决方案","slug":"跨域解决方案","date":"2019-01-09T05:37:29.000Z","updated":"2019-04-28T06:35:29.127Z","comments":true,"path":"2019/01/09/跨域解决方案/","link":"","permalink":"https://leo-wj910729.github.io/2019/01/09/跨域解决方案/","excerpt":"","text":"跨域原因浏览器出于安全考虑,有了同源原则.只要协议,域名,端口号三者有一个不同,都会被当做是不同域解决方案JSONP利用script标签没有跨域限制的特性,通过把src的链接配置为接口的地址,并提供一个回调函数来接受数据12345678910111213function jsop(url,jsonpCb, success) &#123; let script = document.createElement('script') script.src = url script.async = true script.type = 'text/javascript' window[jsonpCb] = function (data) &#123; success &amp;&amp; success() &#125; document.body.appendChild(script)&#125;jsonp('http://xxx', 'callback', function (value) &#123; console.log(value)&#125;)CORSCORS定义了必须访问跨域资源时,浏览器如何与服务器进行沟通基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通,从而决定请求或响应是否成功兼容性,不低于IE10CORS通信的关键在服务器,服务器实现了CORS接口,就可以实现跨域通信,而浏览器端,无需做任何更改,由浏览器自动完成服务器端对CORS的支持,主要是通过Access-Contril-Allow-Origin来进行,该属性用于标识哪些域名可以跨域访问,如果浏览器检测到域名匹配则可以进行跨域访问postMessagewindow.postMessage提供了一种受控机制来规避此限制,可以安全的实现跨源通信当postMessage方法被调用时,会在页面脚本执行完毕后,会发送一个MessageEvent给目标窗口MessageEvent含四个属性1234567let messageCb = function (event) &#123; let message = event.message // 消息类型,消息名称 let source = event.source // 消息源window对象 let origin = event.origin // 消息来源地址 let data = event.data // 发送过来的消息&#125;window.addEventListener('message', messageCb, false)Nginx反向代理123456789server &#123; listen 80; server_name www.xxx.com; location / &#123; proxy_pase api.xxx.com; index index.html index.htm; &#125;&#125;","categories":[],"tags":[{"name":"browser","slug":"browser","permalink":"https://leo-wj910729.github.io/tags/browser/"}]},{"title":"NodeJs的fs模块","slug":"NodeJs的fs模块","date":"2018-11-26T08:53:53.000Z","updated":"2019-04-30T05:36:51.069Z","comments":true,"path":"2018/11/26/NodeJs的fs模块/","link":"","permalink":"https://leo-wj910729.github.io/2018/11/26/NodeJs的fs模块/","excerpt":"","text":"fs模块1234567891011121314151617// 打开文件fs.open('test.txt', 'r+', function (err, fd) &#123; if (err) &#123; return console.error(err); &#125; console.log(\"文件打开成功！\"); &#125;)// 获取文件信息fs.stat('test.txt', function (err, status) &#123; status.isFile() // 是否为文件 status.isDirectory() // 是否为文件夹 status.isBlockDevice() // 是否是块设备 status.isCharacterDevice() // 是否是字符设备 status.isSymbolicLink() // 是否是软链接 status.isFIFO() // 是否是FIFO status.isSocket() // 是否是Socket&#125;)对文件夹的操作的一些命令总结读取文件夹 fs.readdir(path, callback)创建文件夹 fs.mkdir(path, cb)删除文件夹 fs.rmdir(path, callback)对文件的操作的一些命令总结关闭文件 fs.close(fd, callback)读取文件 fs.read(fd, buffer, offset, length, position, callback)写入文件 fs.writeFile(file, data[, options], callback)删除文件 fs.unlink(path, cb)截取文件 fs.ftruncate(fd, len, callback)同步与异步将文件复制至缓存区,然后从缓存区读取文件同步读取文件特点 在读取操作结束下,无法进行下一步操作12let data = fs.readFileSync('test.txt', 'utf8')console.log(data) // 文件数据异步读取文件特点 在读取操作结束下,可以进行下一步操作,在读取结束后,会将读取结果用参数形式传入回调函数,并执行回调函数1234fs.readFile('test.txt', 'utf8', function (err) &#123; if (err) console.log('读取失败') else console.log('读取成功')&#125;)同步与异步将文件复制至缓存区,然后从缓存区写入文件中同步读取文件特点 在读取操作结束下,无法进行下一步操作1fs.writeFileSync('test.txt', 'hello world')异步读取文件特点 在读取操作结束下,可以进行下一步操作,在读取结束后,会将读取结果用参数形式传入回调函数,并执行回调函数1234fs.writeFile('test.txt', 'hello world', function (err) &#123; if(err) console.log('写文件操作失败'); else console.log('写文件操作成功');&#125;)同步或异步分块式读取文件内容fs.read(fd, buffer, offset, length, position, callback)参数说明:fd 文件名buffer 数据写入的缓存区offset 缓冲区写入的偏移量length 要读取的字符数position 文件读取的起始位置 为null时,从文件指针位置开始callback 回调函数异步读取文件特点12345let buffer = new Buffer(255)fs.read('test.txt', buffer, 0, 3, null,function (err,bytesRead,buffer) &#123; if(err) console.log('写文件操作失败'); else console.log('写文件操作成功');&#125;)同步读取文件特点1fs.readSync('test.txt', buff, 0, 3, null)创建一个读取/写入流fs.createReadStream('test.txt')读取流1234567891011121314151617const fs = require('fs');let readStream = fs.createReadStream('./message.txt', &#123;start:3,end:12&#125;);readStream.on('open', function (fd) &#123; console.log('开始读取文件');&#125;);readStream.on('data', function (data) &#123; console.log('读取到数据：', data);&#125;);readStream.on('end', function () &#123; console.log('文件已全部读取完毕');&#125;);readStream.on('close', function () &#123; console.log('文件被关闭');&#125;);readStream.on('error', function (err) &#123; console.log('读取文件失败');&#125;);写入流12345678910111213141516const fs = require('fs');const file = fs.createReadStream('./message.txt');let out = fs.createWriteStream('./anotherMessage.txt');file.on('data', function (data) &#123; out.write(data);&#125;);out.on('open', function (fd) &#123; console.log('需要被写入的文件已打开');&#125;);file.on('end', function () &#123; //将操作系统缓存区中的数据全部写入文件 out.end('再见', function () &#123; console.log('文件全部写入完毕'); console.log('共写入'+out.bytesWritten+'数据'); &#125;);&#125;);","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://leo-wj910729.github.io/tags/Node/"}]},{"title":"Git的基础操作指令","slug":"git-base","date":"2018-10-12T16:00:00.000Z","updated":"2019-04-28T06:49:01.108Z","comments":true,"path":"2018/10/13/git-base/","link":"","permalink":"https://leo-wj910729.github.io/2018/10/13/git-base/","excerpt":"","text":"全局配置Git操作配置全局信息123$ git config --global user.name \"henry\"$ git config --global user.email henry@example.com$ git config --global alias.&lt;alias-name&gt; &lt;命令名&gt; // 设置别名 如 git ci 等价于 git commit初始化本地仓库1$ git init查询当前文件状态1$ git status添加文件到git暂存区12$ git add 文件名$ git add . // 添加所有文件到暂存区提交暂存区文件到git本地仓库12$ git commit -m '提交信息'$ git commit --amend // 重新提交撤销暂存区文件1$ git reset HEAD 文件名查看远程仓库12$ git remote$ git remote -v // 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL添加远程仓库1$ git remote add &lt;remote-name&gt; &lt;url&gt; // 添加一个新的远程Git仓库拉去远程仓库到本地1$ git fetch &lt;remote-name&gt;推送到远程仓库1$ git pull &lt;remote-name&gt; &lt;branch-name&gt;修改远程仓库名称1$ git remote rename &lt;remote-name&gt; &lt;new-remote-name&gt;删除远程仓库1$ git remote rm &lt;remote-name&gt;查看所有标签12$ git tag$ git tag -l '搜索词'创建标签123$ git tag &lt;tag-name&gt; // 创建一个轻量标签$ git tag -a &lt;tag-name&gt; -m '存储在标签中的信息' // -a 创建一个携带标签信息的标签 -m 标签信息$ git tag -a &lt;tag-name&gt; 提交的校验和（或部分校验和） // 给过去的提交打标签将标签推送到远程12$ git push &lt;remote-name&gt; &lt;tag-name&gt; // 推送一个tag到远端$ git push &lt;remote-name&gt; --tags // 推送多个tag到远端删除标签12$ git tag -d &lt;tag-name&gt; // 本地删除一个指定的tag$ git push &lt;remote-name&gt; :refs/tags/&lt;tag-name&gt; // 远端删除一个指定的tag检出标签12$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag分支操作创建分支删除分支1$ git brach -d查询分支1$ git branch","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"git","slug":"git","permalink":"https://leo-wj910729.github.io/tags/git/"}]},{"title":"箭头函数与普通函数的区别","slug":"箭头函数与普通函数的区别","date":"2018-08-14T03:08:17.000Z","updated":"2019-04-28T06:35:01.128Z","comments":true,"path":"2018/08/14/箭头函数与普通函数的区别/","link":"","permalink":"https://leo-wj910729.github.io/2018/08/14/箭头函数与普通函数的区别/","excerpt":"","text":"箭头函数12345678910let arrowFn = (...args) =&gt; &#123; // 箭头函数没有arguments属性 // 箭头函数没有原型属性 // 箭头函数不能当做generator函数,也不能使用yield关键字 // 箭头函数作用域永远指向父级作用域,call,apply,bind都无法改变 console.log('箭头函数', arguments) // Uncaught ReferenceError: arguments is not defined console.log('箭头函数', args) // 因为没有arguments属性,使用...扩展符来获取&#125;// 箭头函数不可以作为构造函数,因为其特性,this永远指向父级作用域,而构造函数的第一步就是将this赋值为生成的空对象new arrowFn() // Uncaught TypeError: FunConstructor is not a constructor普通函数123let normalFn = function () &#123; console.log('普通函数')&#125;","categories":[],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"函数的节流","slug":"throttle","date":"2018-08-12T16:00:00.000Z","updated":"2019-06-08T01:01:45.704Z","comments":true,"path":"2018/08/13/throttle/","link":"","permalink":"https://leo-wj910729.github.io/2018/08/13/throttle/","excerpt":"","text":"定义当持续触发事件时,在规定的时间内只触发一次,如果在规定的时间内再次触发事件,则不做任何操作应用场景监听是否滚动到底部,而触发上拉加载原理时间戳形式,通过闭包保存上一次的时间戳,将其与事件触发时的时间戳进行比较,如果差值大于设定的时间,则调用事件,并记录时间戳,否则不进行任何操作定时器形式,通过闭包保存定时器,事件触发时,如果定时器为null,则执行cb,并设置新的定时器实现方法时间戳形式123456789101112function throttle (cb, delay = 16) &#123; let prevTime = 0 return function (...args) &#123; let now = Date.now() let that = this let _args = args if (now &gt; prevTime + delay) &#123; fun.apply(that, _args) prevTime = now &#125; &#125;&#125;定时器形式12345678910111213function throttle (cb, delay = 16) &#123; let timer = null return function (...args) &#123; let that = this let _args = args if (!timer) &#123; timer = setTimeout(function () &#123; timer = null cb.apply(that, _args) &#125;,delay) &#125; &#125;&#125;时间戳加定时器的形式12345678910111213141516171819function throttle (cb, delay = 16) &#123; let timer = null let prevTime = 0 return function (...args) &#123; let that = this let _args = args let now = Date.now() let tag = delay - (now - prevTime) clearTimeout(timer) if (tag &lt; 0) &#123; cb.apply(that, delay) prevTime = Date.now() &#125; else &#123; timer = setTimeout(function () &#123; cb.apply(that, delay) &#125;, ta) &#125; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"nrm的使用","slug":"nrm","date":"2018-07-19T16:00:00.000Z","updated":"2019-06-08T01:41:26.000Z","comments":true,"path":"2018/07/20/nrm/","link":"","permalink":"https://leo-wj910729.github.io/2018/07/20/nrm/","excerpt":"","text":"安装 (已安装git的情况下)123$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash$ 或者$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash设置全局路径这四个文件中的一个 ~/.bashrc, ~/.bash_profile, ~/.zshrc, ~/.profile 文件下添加123$ export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm$ source .bash_profile // 启用$ nvm ls // 测试使用1$ nvm ls // 展示现有node版本列表卸载1234$ cd ~$ rm -rf .nvm$ // 去除上面设置的全局路径$ source .bash_profile","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"nrm","slug":"nrm","permalink":"https://leo-wj910729.github.io/tags/nrm/"}]},{"title":"函数的防抖","slug":"dounce","date":"2018-07-05T16:00:00.000Z","updated":"2019-04-28T06:33:34.709Z","comments":true,"path":"2018/07/06/dounce/","link":"","permalink":"https://leo-wj910729.github.io/2018/07/06/dounce/","excerpt":"","text":"定义触发时间后的一段时间内,该事件的回调函数仅会触发一次,如果在规定时间内再次触发该事件,则重新开始计算时间 游戏理解: 法师读条法术,进度条未读完再次释放则会打断上次施法应用场景用户连续操作导致事件频发触发回调用户只关系操作之后的结果(滚动条啊,搜索输入啊,这种)原理通过定时器将回调函数进行延时,在规定时间内继续回调,发现存在之前的定时器时,清空该定时器并重新设置新的定时器实现方法非立即执行版本: 事件触发=&gt; 延时=&gt; 执行回调函数 在延时中触发事件,则会重新进行延时,延时结束后执行回调函数1234567891011121314151617181920function debounce (cb, delay = 16) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(cb.timer) cb.timer = setTimout(function () &#123; cb.call(that, _args) &#125;, delay) &#125;&#125;function cb () &#123; console.log('这是一个回调函数', arguments)&#125;let debounceFn = debounce(cb)let input = document.getElementById('test-input')input.addEventListener('keyup', function (e) &#123; debounceFn(e.target.value)&#125;)立即执行版本: 事件触发=&gt; 执行回调函数=&gt; 延时 在延时中触发事件,则会重新进行延时,延时结束,并不会执行回调函数123456789101112131415161718function debounce (cb, immediate = true, delay = 16) &#123; let timer = null return function (args) &#123; let that = this let _args = args if (timer) clearTimeout(timer) if (immediate) &#123; if(!timer) cb.apply(that, args) timer = setTimeout(function () &#123; timer = null &#125;, delay) &#125; else &#123; timer = setTimeout(function () &#123; cb.apply(that, args) &#125;,delay) &#125; &#125;&#125;// 防抖就是在一段时间内如果没有操作,则执行函数,如果有操作,则清除定时器重新执行 // 节流就是在一段时间内只会触发一次函数操作","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"垃圾回收机制","slug":"GarbageCollection","date":"2018-06-22T16:00:00.000Z","updated":"2019-04-28T06:33:08.785Z","comments":true,"path":"2018/06/23/GarbageCollection/","link":"","permalink":"https://leo-wj910729.github.io/2018/06/23/GarbageCollection/","excerpt":"","text":"垃圾回收机制javascript有内置的垃圾回收机制GC,执行环境在管理代码执行过程中使用的内存,内存的分配和回收全都由js引擎来管理内存生命周期内存分配阶段: 声明变量,函数,对象并执行时,系统会自动为其分配内存内存使用阶段: 使用变量,函数时内存回收阶段: 变量,函数被使用完毕,由GC机制回收垃圾回收机制的策略标记清除法: mark-and-sweep算法:标记阶段: GC从根开始遍历,凡是可以到达根的对象,都是仍需要使用的对象,被标记清除阶段: GC会对堆内存从头到尾进行线性遍历,发现对象没有被标记则将其占用的内存回收,标记了的对象被去除标记缺陷不能从根对象查询到的对象都会被清除GC后会产生大量的内存碎片,因为对象需要连续的内存单位,可能会导致内存碎片持续未被使用,直到内存溢出引用计数法算法:对象是否未被其他对象引用缺陷:无法处理循环引用,创建两个对象,互相引用,则这两个对象永远无法被垃圾回收,从而导致内存溢出V8垃圾回收算法chrome的v8引擎采用了分代回收策略,将内存对象分为临时对象和持久对象临时对象和持久对象的回收机制并不相同因为GC会导致js线程暂停执行,一次较长的GC可能会持续1s以上的时间,所以通过持续回收临时对象来减少GC的执行时间V8的内存限制在node中javascript可使用的内存有限制64位系统下约1.4GB,临时对象存储空间约32MB32位系统下约0.7GB,临时对象存储空间约16MB临时对象临时对象的存储空间将会被均分为两块,只有一块处于使用状态,其被称为FROM空间,另一块则闲置,被称为TO空间 GC时,将FROM空间中的临时对象中的存活对象进行标记,GC结束后将被标记对象复制到TO空间中,将FROM空间的内存清空,此时FROM空间与TO空间角色互换,如此循环**缺陷:**减少了空间的使用,换来了时间上的节省**优点:**极其适合临时对象的垃圾回收,因为临时对象生命周期短,适合该算法晋升机制当一个对象经过多次复制后依然存在,其就会被标记为持久对象,被移动至持久对象存储空间中晋升条件对象经历过临时存储空间的GC临时存储空间中的TO空间被占据25%以上持久对象持久对象的存储空间较大,存储的对象较多,使用临时对象的那种GC算法牺牲的空间太大,而且持久对象的生命周期较长持久对象的GC算法为mark-and-sweep,即标记-清除,标记非活跃对象,清除非活跃对象 但是mark-and-sweep会导致内存不连续,产生大量的内存碎片,导致内存溢出的可能性 为了解决上述问题引入了一种新的算法Mark-compact,即标记-排列整理,在标记后,将活跃对象往一端移动,移动完成后,清除边界外的内存,但该种算法的执行速度较慢,所以仅在临时对象晋升后的内存分配时使用","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://leo-wj910729.github.io/tags/javascript/"}]},{"title":"希尔排序","slug":"algorithm-shellsort","date":"2018-06-20T16:00:00.000Z","updated":"2019-04-28T06:32:41.146Z","comments":true,"path":"2018/06/21/algorithm-shellsort/","link":"","permalink":"https://leo-wj910729.github.io/2018/06/21/algorithm-shellsort/","excerpt":"","text":"算法介绍1.1 算法描述希尔排序是建立在插入排序上的改进排序方法,对排序情况较好的序列排序时,能够达到较好的排序效率1.2 算法步骤选择一个增量序列,t1, t2, ....,tj,tk 依次减少,最小为1按照增量序列的个数,对序列进行k次排序每次排序根据对应的增量ti,将待排序列分割成若干长度为m的子序列,分别对各子表进行直接插入排序.1.3 算法实现1234567891011121314151617181920funtion shellSort (arr) &#123; let len = arr.length let temp let gap = 1 while (gap &lt; len / 2) &#123; gap = gap * 2 + 1 &#125; for (;gap &gt; 0; gap = Math.floor(gap/2)) &#123; for (let i = gap; i &lt; len; i++) &#123; temp = arr[i] // 按照步进值取出对应的分块数据 arr[2]和arr[0]配对 依次类推 // 该gap值下所分的组进行插值排序 for (let j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; // arr[j] &gt; arr[i] 前值大于后值 arr[j+gap] = arr[j] // 将前值赋值给后值 &#125; arr[j+gap] = temp // &#125; &#125; return arr&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leo-wj910729.github.io/tags/algorithm/"}]},{"title":"快速排序","slug":"algorithm-quicksort","date":"2018-05-19T16:00:00.000Z","updated":"2019-06-08T01:08:02.576Z","comments":true,"path":"2018/05/20/algorithm-quicksort/","link":"","permalink":"https://leo-wj910729.github.io/2018/05/20/algorithm-quicksort/","excerpt":"","text":"算法介绍1.1 算法描述快速排序因为时间复杂度较低,且其核心思想分治法实用性强,算法难度不高,使其流行度较高1.2 算法步骤从数组中取出一个数作为基数对数组进行遍历,将大于该数的数放在基数的右边,小于该数的放在基数的左边对左侧和右侧的数组继续进行上述操作,直至左右侧只有一位数1.3 算法实现12345678910111213funtion quickSort (arr) &#123; if (!arr.isArray) return [] if (!arr.length) return [] let baseIndex = Math.floor(arr.length / 2) let baseNumber = arr.splice(baseIndex, 1)[0] let left = [] let right = [] arr.forEach(item =&gt; &#123; if (item &lt; baseNumber) left.push(item) else right.push(item) &#125;) return quickSort(left).concat(baseNumber,quickSort(right))&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leo-wj910729.github.io/tags/algorithm/"}]},{"title":"docker基础知识","slug":"dcoker-base","date":"2018-03-25T16:00:00.000Z","updated":"2019-06-12T08:17:10.490Z","comments":true,"path":"2018/03/26/dcoker-base/","link":"","permalink":"https://leo-wj910729.github.io/2018/03/26/dcoker-base/","excerpt":"","text":"docker的核心镜像可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。 每次对镜像的修改都会产生一个新的镜像层,该镜像层基于修改前的镜像。 镜像内存储的是不可变的文件。容器用于隔离虚拟环境的基础设施。 如果将镜像比作类,那么容器就是类的实例 容器是活的空间,内部文件可变网络利用一些技术,DOcker能够在容器中营造出独立的域名解析环境,这意味着我们不需要付出任何代价就可以创造出同一环境的容器 两台物理机上的docker容器,可以加入同一个虚拟网络中数据卷可以挂载在宿主操作系统中的目录上 容器内建立独立的目录持久存放数据 容器间共享","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://leo-wj910729.github.io/tags/docker/"}]},{"title":"docker-volume 数据卷","slug":"docker-volumeManager","date":"2018-03-20T16:00:00.000Z","updated":"2019-06-12T10:15:43.421Z","comments":true,"path":"2018/03/21/docker-volumeManager/","link":"","permalink":"https://leo-wj910729.github.io/2018/03/21/docker-volumeManager/","excerpt":"","text":"Docker数据管理方式沙盒文件系统会随着容器生命周期而创建和移除,数据无法直接被持久化存储因为容器隔离,我们很难从容器外部操作和查看容器内部文件中的数据文件系统挂载的方式Bind Mount将宿主操作系统中的目录文件挂载到容器内的文件系统中,通过制定容器外的路径和容器内路径,形成挂载映射关系,在容器内外对文件的读写,都是互相可见的12$ docker run -d --name &lt;container-name&gt; -v &lt;host-path&gt;:&lt;container-path&gt;:ro &lt;image&gt;$ docker inspect &lt;container-name&gt;通过在挂载路径后加入:ro可以实现只读挂载,容器内部程序将无法对目录和文件进行修改Volume从宿主操作系统中挂载目录到容器内,但挂载的目录由Docker管理,我们只需要制定容器内的目录,不需要关系具体挂载到了宿主操作系统中的哪个文件夹下使用数据卷进行挂载时,依然可以使用-v或--volume选项来定义数据卷的挂载,路径需要是绝对路径12$ docker run -d --name &lt;container-name&gt; -v &lt;container-path&gt; &lt;image&gt;$ docker inspect &lt;container-name&gt;为了方便对数据卷的管理,我们可以对数据卷命名,在我们未给出数据卷命名时,Docker会使用数据卷的Id命名数据卷,我们可以通过-v &lt;name&gt;:&lt;container-path&gt;来命名数据卷,路径需要是绝对路径12$ docker run -d --name &lt;container-name&gt; -v &lt;volume-name&gt;:&lt;container-path&gt;$ docker inspect &lt;container-name&gt;使用场景希望数据在多个容器间共享希望对容器内挂载的内容进行管理当使用远程服务器或云服务作为存储介质的时候,数据卷可以隐藏更多细节,让容器构建过程更加清晰简单Tmpfs Mount支持挂载系统内存中的一部分到容器的文件系统里,由于内存和容器的特征,其存储并非持久的,其中的内容会随着容器的停止而消失与挂载宿主操作系统目录或文件不同,挂载临时文件目录要通过--tmpfs这个选项来完成,由于内存的具体位置不需要我们来指定,这个选项里只需要传递挂载到容器内的目录就行了12$ docker run -d --name &lt;container-name&gt; --tmpfs &lt;container-path&gt; &lt;image&gt;$ docker inspect &lt;container-name&gt;数据卷相关操作当我们使用-v来挂载数据卷时,如果数据卷不存在,Docker会为我们自动创建和分配宿主操作系统的目录,如果同名数据卷已经存在,则会直接引用1234$ docker volume ls 列出当前已创建的数据卷$ docker volume create &lt;volume-name&gt; 创建不依赖容器的数据卷$ docker volume rm &lt;volume-name&gt; 删除指定的数据卷$ docker volume prune 删除没有被容器引用的数据卷在删除容器的命令中.我们可以通过增加-v选项来删除容器关联的数据卷1$ docker rm -v &lt;container-name&gt;数据卷容器数据卷容器,不需要容器本身运行,可以找个简单系统镜像完成创建使用数据卷容器时,不建议定义数据卷的名称,因为我们可以通过数据卷容器的引用来完成数据卷的引用数据卷容器是容器间文件系统的桥梁,我们可以通过--volumes-from选项来引用数据卷容器1$ sudo docker run -d --name &lt;container-name&gt; --volumes-from &lt;volume-container-name&gt; &lt;image&gt;引用数据卷容器时,无需定义数据卷挂载到容器中的位置,Docker会以数据卷容器中的挂载定义将数据卷挂载到引用的容器中备份和迁移数据卷由于数据卷本身就是宿主操作系统中的一个目录,只需要在Docker资源目录中找到就可以轻松的打包,迁移,恢复利用数据卷容器,我们可以非常方便的对数据卷中的数据进行迁移通过建立临时容器,将用于备份的目录和要备份的数据卷都挂载到这个容器上1$ docker run --rm --volumes-from &lt;volumes-container-name&gt; -v &lt;host-path&gt;:&lt;container-path&gt; &lt;image&gt; tar cvf &lt;host-file&gt; &lt;container-path&gt;上面的命令的意思是创建一个在停止运行后会自动删除的临时容器,操作系统的指定文件路径绑定挂载到容器的指定文件路径上, 并解压缩指定文件到容器的指定文件夹中1$ docker run --rm --volumes-from &lt;volumes-container-name&gt; -v &lt;host-path&gt;:&lt;container-path&gt; &lt;image&gt; tar xvf &lt;host-file&gt; -C &lt;container-path&gt; --strip","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://leo-wj910729.github.io/tags/docker/"}]},{"title":"docker-volume 数据卷","slug":"docker-volume","date":"2018-03-20T16:00:00.000Z","updated":"2019-06-12T10:15:04.335Z","comments":true,"path":"2018/03/21/docker-volume/","link":"","permalink":"https://leo-wj910729.github.io/2018/03/21/docker-volume/","excerpt":"","text":"数据卷的几种形态不使用数据卷默认情况下docker容器不使用任何volume,此时,容器的数据被保存在容器中,当容器被删除时,数据也被删除,我们可以使用docker commit 将该容器持久化为一个镜像Data volume (数据卷)使用&quot;-v 容器内目录&quot;形式,将本地一个_data目录挂载为容器内的webapp目录12345678910111213$ docker run -d -P --name web -v /webapp training/webapp python app.py$ docker inspect $ \"Mounts\": [ &#123; \"Name\": \"f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b\", \"Source\": \"/var/lib/docker/volumes/f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b/_data\", \"Destination\": \"/webapp\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" &#125;]使用-v挂载主机上的一个文件到容器内的一个文件1docker run --rm -it -v ~/.bash_history:/root/.bash_history ubuntu /bin/bashData container (容器数据卷)在容器间共享数据,可以使用容器来进行数据的存储,这样的容器不会跑应用,而仅仅是挂载一个数据卷缺点: 容器可以被删除 优点: 可以持续重复的使用数据12345678910111213141516$ 创建一个数据卷容器$ docker create -v /dbdata --name dbstore training/webapp /bin/true$ 运行数据卷容器$ docker run -d -P --name web3 --volumes-from dbstore training/webapp python app.py$ docker inspect$ \"Mounts\": [ &#123; \"Name\": \"5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330\", \"Source\": \"/var/lib/docker/volumes/5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330/_data\", \"Destination\": \"/dbdata\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" &#125;]使用docker volume命令创建数据卷12$ docker volume create --name 数据卷名$ docker volume inspect 数据卷名使用数据卷1$ docker run -d -P --name 容器名 -v 数据卷名:/volume training/webapp python app.p","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://leo-wj910729.github.io/tags/docker/"}]},{"title":"docker-containerToImage 导入导出镜像","slug":"docker-containerToImage","date":"2018-03-20T16:00:00.000Z","updated":"2019-06-13T01:48:17.396Z","comments":true,"path":"2018/03/21/docker-containerToImage/","link":"","permalink":"https://leo-wj910729.github.io/2018/03/21/docker-containerToImage/","excerpt":"","text":"容器修改,镜像保存给保存的镜像命名将容器修改的内容保存为镜像使用docekr commit1$ docker commit -m \"提交信息\" &lt;image&gt;:&lt;tag&gt; &lt;new-image&gt;:&lt;tag&gt;将容器内沙盒文件系统记录成镜像层的时候,会先暂停容器的运行如何给未命名的镜像命名1$ docker tag &lt;imageId&gt; &lt;new-image&gt;:&lt;tag&gt;给已有的镜像新的命名1$ docker tag &lt;image&gt;:&lt;tag&gt; &lt;new-image&gt;:&lt;tag&gt;镜像迁移当我们将对容器的更改导出为镜像后,就可以开始对镜像的迁移操作镜像导出使用管道符导出镜像到文件1$ docker save &lt;image&gt;:&lt;tag&gt; &gt; &lt;file-name&gt;在默认定义下,docker save命令会将镜像内容放入输出流中,需要使用&gt;管道符号将其导入到文件当中使用-o指定输出文件1$ docker save -o &lt;file-name&gt; &lt;image&gt;:&lt;tag&gt;镜像导入使用管道符导入镜像1$ docker load &lt; &lt;file-name&gt;使用-i指定输入文件1$ docker load -i &lt;file-name&gt;导入的镜像会应用原有的镜像名称对容器的导出迁移的合并操作 export使用docker commit 和 docker save 操作来讲容器更改打包为文件的操作可能有些繁琐,我们可以使用docker export 来进行将指定镜像打包到指定文件1$ docker export -o &lt;file-name&gt; &lt;image&gt;:&lt;tag&gt;将指定文件导出为镜像1$ docker import &lt;file-name&gt; &lt;image&gt;:&lt;tag&gt;","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://leo-wj910729.github.io/tags/docker/"}]},{"title":"从创建到发布-hexo的文章编写发布流程","slug":"hexo-deploy","date":"2018-02-10T16:00:00.000Z","updated":"2019-04-24T03:01:10.795Z","comments":true,"path":"2018/02/11/hexo-deploy/","link":"","permalink":"https://leo-wj910729.github.io/2018/02/11/hexo-deploy/","excerpt":"","text":"这是一段描述&lt;!-- more --&gt;快速开始创建一篇文章1$ hexo new \"一篇新的文章\"More info: Writing运行hexo服务1$ hexo serverMore info: Server生成静态文件1$ hexo generateMore info: Generating发布静态博客1$ hexo deployMore info: Deployment","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://leo-wj910729.github.io/tags/hexo/"}]}]}