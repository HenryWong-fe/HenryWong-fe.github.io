{"meta":{"title":"林中小屋","subtitle":"宁静致远","description":null,"author":"Henry Wang","url":"https://leo-wj910729.github.io","root":"/"},"pages":[{"title":"Henry的小简历","date":"2019-04-21T04:47:25.000Z","updated":"2019-04-21T11:54:49.641Z","comments":true,"path":"about/index.html","permalink":"https://leo-wj910729.github.io/about/index.html","excerpt":"","text":"工作经历北京源石云科技有限公司上海分公司 2018.3 - 至今工作内容 负责App版本迭代,节日活动,内部管理后台,项目公用库维护,项目脚手架编写及维护,代码风格制定,分支代码合并及管理 项目经验 项目脚手架,微博内嵌商城,金币系统,大牌闪降,砍价,零元拼团,数码产品回收,拼团,各类活动页上海得仕网络科技有限公司 2017.3 - 2018.2工作内容 负责得仕彩票web端页面开发,利是利员工福利App混合开发,负责制定代码规范,代码合并及管理 项目经验 得仕彩票web端页面,利是利员工福利平台App页面开发杭州引力科技有限公司 2015.5 - 2017.2工作内容 负责公司后台页面开发,公司外包业务开发 项目经验 公司外包页面"},{"title":"标签","date":"2019-04-21T06:19:30.914Z","updated":"2019-04-21T06:19:30.914Z","comments":false,"path":"tags/index.html","permalink":"https://leo-wj910729.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-04-21T06:20:50.859Z","updated":"2019-04-21T06:20:50.859Z","comments":false,"path":"/404.html","permalink":"https://leo-wj910729.github.io//404.html","excerpt":"","text":"&lt;script type=&quot;text/javascript&quot; src=&quot;//www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;&lt;%- config.url %&gt;&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt;"},{"title":"分类","date":"2019-04-21T06:20:23.551Z","updated":"2019-04-21T06:20:23.550Z","comments":false,"path":"categories/index.html","permalink":"https://leo-wj910729.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-21T06:20:24.372Z","updated":"2019-04-21T06:20:24.372Z","comments":false,"path":"repository/index.html","permalink":"https://leo-wj910729.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"函数的节流","slug":"throttle","date":"2019-02-12T16:00:00.000Z","updated":"2019-04-25T11:06:28.918Z","comments":true,"path":"2019/02/13/throttle/","link":"","permalink":"https://leo-wj910729.github.io/2019/02/13/throttle/","excerpt":"","text":"定义当持续触发事件时,在规定的时间内只触发一次,如果在规定的时间内再次触发事件,则不做任何操作应用场景监听是否滚动到底部,而触发上拉加载原理时间戳形式,通过闭包保存上一次的时间戳,将其与事件触发时的时间戳进行比较,如果差值大于设定的时间,则调用事件,并记录时间戳,否则不进行任何操作定时器形式,通过闭包保存定时器,事件触发时,如果定时器为null,则执行cb,并设置新的定时器实现方法时间戳形式123456789101112function throttle (cb, delay = 16) &#123; let prevTime = 0 return function (args) &#123; let now = Date.now() let that = this let _args = args if (now &gt; prevTime + delay) &#123; fun.apply(that, _args) prevTime = now &#125; &#125;&#125;定时器形式12345678910111213function throttle (cb, delay = 16) &#123; let timer = null return function (args) &#123; let that = this let _args = args if (!timer) &#123; timer = setTimeout(function () &#123; timer = null cb.apply(that, _args) &#125;,delay) &#125; &#125;&#125;时间戳加定时器的形式12345678910111213141516171819function throttle (cb, delay = 16) &#123; let timer = null let prevTime = 0 return function (args) &#123; let that = this let _args = args let now = Date.now() let tag = delay - (now - prevTime) clearTimeout(timer) if (tag &lt; 0) &#123; cb.apply(that, delay) prevTime = Date.now() &#125; else &#123; timer = setTimeout(function () &#123; cb.apply(that, delay) &#125;, ta) &#125; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"Git的基础操作指令","slug":"git-base","date":"2019-02-12T16:00:00.000Z","updated":"2019-04-24T03:01:43.090Z","comments":true,"path":"2019/02/13/git-base/","link":"","permalink":"https://leo-wj910729.github.io/2019/02/13/git-base/","excerpt":"","text":"全局配置Git操作配置全局信息123$ git config --global user.name \"henry\"$ git config --global user.email henry@example.com$ git config --global alias.&lt;alias-name&gt; &lt;命令名&gt; // 设置别名 如 git ci 等价于 git commit初始化本地仓库1$ git init查询当前文件状态1$ git status添加文件到git暂存区12$ git add 文件名$ git add . // 添加所有文件到暂存区提交暂存区文件到git本地仓库12$ git commit -m '提交信息'$ git commit --amend // 重新提交撤销暂存区文件1$ git reset HEAD 文件名查看远程仓库12$ git remote$ git remote -v // 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL添加远程仓库1$ git remote add &lt;remote-name&gt; &lt;url&gt; // 添加一个新的远程Git仓库拉去远程仓库到本地1$ git fetch &lt;remote-name&gt;推送到远程仓库1$ git pull &lt;remote-name&gt; &lt;branch-name&gt;修改远程仓库名称1$ git remote rename &lt;remote-name&gt; &lt;new-remote-name&gt;删除远程仓库1$ git remote rm &lt;remote-name&gt;查看所有标签12$ git tag$ git tag -l '搜索词'创建标签123$ git tag &lt;tag-name&gt; // 创建一个轻量标签$ git tag -a &lt;tag-name&gt; -m '存储在标签中的信息' // -a 创建一个携带标签信息的标签 -m 标签信息$ git tag -a &lt;tag-name&gt; 提交的校验和（或部分校验和） // 给过去的提交打标签将标签推送到远程12$ git push &lt;remote-name&gt; &lt;tag-name&gt; // 推送一个tag到远端$ git push &lt;remote-name&gt; --tags // 推送多个tag到远端删除标签12$ git tag -d &lt;tag-name&gt; // 本地删除一个指定的tag$ git push &lt;remote-name&gt; :refs/tags/&lt;tag-name&gt; // 远端删除一个指定的tag检出标签12$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag分支操作创建分支删除分支1$ git brach -d查询分支1$ git branch","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"git","slug":"git","permalink":"https://leo-wj910729.github.io/tags/git/"}]},{"title":"函数的防抖","slug":"dounce","date":"2019-02-12T16:00:00.000Z","updated":"2019-04-25T09:10:13.479Z","comments":true,"path":"2019/02/13/dounce/","link":"","permalink":"https://leo-wj910729.github.io/2019/02/13/dounce/","excerpt":"","text":"定义触发时间后的一段时间内,该事件的回调函数仅会触发一次,如果在规定时间内再次触发该事件,则重新开始计算时间 游戏理解: 法师读条法术,进度条未读完再次释放则会打断上次施法应用场景用户连续操作导致事件频发触发回调用户只关系操作之后的结果(滚动条啊,搜索输入啊,这种)原理通过定时器将回调函数进行延时,在规定时间内继续回调,发现存在之前的定时器时,清空该定时器并重新设置新的定时器实现方法非立即执行版本: 事件触发=&gt; 延时=&gt; 执行回调函数 在延时中触发事件,则会重新进行延时,延时结束后执行回调函数1234567891011121314151617181920function debounce (cb, delay = 16) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(cb.timer) cb.timer = setTimout(function () &#123; cb.call(that, _args) &#125;, delay) &#125;&#125;function cb () &#123; console.log('这是一个回调函数', arguments)&#125;let debounceFn = debounce(cb)let input = document.getElementById('test-input')input.addEventListener('keyup', function (e) &#123; debounceFn(e.target.value)&#125;)立即执行版本: 事件触发=&gt; 执行回调函数=&gt; 延时 在延时中触发事件,则会重新进行延时,延时结束,并不会执行回调函数123456789101112131415161718function debounce (cb, immediate = true, delay = 16) &#123; let timer = null return function (args) &#123; let that = this let _args = args if (timer) clearTimeout(timer) if (immediate) &#123; if(!timer) cb.apply(that, args) timer = setTimeout(function () &#123; timer = null &#125;, delay) &#125; else &#123; timer = setTimeout(function () &#123; cb.apply(that, args) &#125;,delay) &#125; &#125;&#125;// 防抖就是在一段时间内如果没有操作,则执行函数,如果有操作,则清除定时器重新执行 // 节流就是在一段时间内只会触发一次函数操作","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"快速排序","slug":"algorithm-quicksort","date":"2018-04-10T16:00:00.000Z","updated":"2019-04-24T02:59:37.759Z","comments":true,"path":"2018/04/11/algorithm-quicksort/","link":"","permalink":"https://leo-wj910729.github.io/2018/04/11/algorithm-quicksort/","excerpt":"","text":"算法介绍1.1 算法描述快速排序因为时间复杂度较低,且其核心思想分治法实用性强,算法难度不高,使其流行度较高1.2 算法步骤从数组中取出一个数作为基数对数组进行遍历,将大于该数的数放在基数的右边,小于该数的放在基数的左边对左侧和右侧的数组继续进行上述操作,直至左右侧只有一位数1.3 算法实现12345678910111213funtion quickSort (arr) &#123; if (!arr.isArray) return [] if (!arr.length) return [] let baseIndex = Math.floor(arr.length / 2) let baseNumber = arr.splice(baseIndex, 1)[0] let left = [] let right = [] arr.forEach(item =&gt; &#123; if (item &lt; baseNumber) left.push(item) else right.push(item) &#125;) return quickSort(left).concat(baseNumber,quickSort(right))&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leo-wj910729.github.io/tags/algorithm/"}]},{"title":"希尔排序","slug":"algorithm-shellsort","date":"2018-04-10T16:00:00.000Z","updated":"2019-04-24T06:05:14.887Z","comments":true,"path":"2018/04/11/algorithm-shellsort/","link":"","permalink":"https://leo-wj910729.github.io/2018/04/11/algorithm-shellsort/","excerpt":"","text":"算法介绍1.1 算法描述希尔排序是建立在插入排序上的改进排序方法,对排序情况较好的序列排序时,能够达到较好的排序效率1.2 算法步骤选择一个增量序列,t1, t2, ....,tj,tk 依次减少,最小为1按照增量序列的个数,对序列进行k次排序每次排序根据对应的增量ti,将待排序列分割成若干长度为m的子序列,分别对各子表进行直接插入排序.1.3 算法实现1234567891011121314151617181920funtion shellSort (arr) &#123; let len = arr.length let temp let gap = 1 while (gap &lt; len / 2) &#123; gap = gap * 2 + 1 &#125; for (;gap &gt; 0; gap = Math.floor(gap/2)) &#123; for (let i = gap; i &lt; len; i++) &#123; temp = arr[i] // 按照步进值取出对应的分块数据 arr[2]和arr[0]配对 依次类推 // 该gap值下所分的组进行插值排序 for (let j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; // arr[j] &gt; arr[i] 前值大于后值 arr[j+gap] = arr[j] // 将前值赋值给后值 &#125; arr[j+gap] = temp // &#125; &#125; return arr&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leo-wj910729.github.io/tags/algorithm/"}]},{"title":"docker基础知识","slug":"dcoker-base","date":"2018-03-25T16:00:00.000Z","updated":"2019-04-24T03:00:58.466Z","comments":true,"path":"2018/03/26/dcoker-base/","link":"","permalink":"https://leo-wj910729.github.io/2018/03/26/dcoker-base/","excerpt":"","text":"docker的核心镜像可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。 每次对镜像的修改都会产生一个新的镜像层,该镜像层基于修改前的镜像。 镜像内存储的是不可变的文件。容器用于隔离虚拟环境的基础设施。 如果将镜像比作类,那么容器就是类的实例 容器是活的空间,内部文件可变网络利用一些技术,DOcker能够在容器中营造出独立的域名解析环境,这意味着我们不需要付出任何代价就可以创造出同一环境的容器 两台物理机上的docker容器,可以加入同一个虚拟网络中数据卷可以挂载在宿主操作系统中的目录上 容器内建立独立的目录持久存放数据 容器间共享","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://leo-wj910729.github.io/tags/docker/"}]},{"title":"docker-volume 数据卷","slug":"docker-volume","date":"2018-03-20T16:00:00.000Z","updated":"2019-04-24T03:00:50.962Z","comments":true,"path":"2018/03/21/docker-volume/","link":"","permalink":"https://leo-wj910729.github.io/2018/03/21/docker-volume/","excerpt":"","text":"数据卷的几种形态不使用数据卷默认情况下docker容器不使用任何volume,此时,容器的数据被保存在容器中,当容器被删除时,数据也被删除,我们可以使用docker commit 将该容器持久化为一个镜像Data volume (数据卷)使用&quot;-v 容器内目录&quot;形式,将本地一个_data目录挂载为容器内的webapp目录12345678910111213$ docker run -d -P --name web -v /webapp training/webapp python app.py$ docker inspect $ \"Mounts\": [ &#123; \"Name\": \"f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b\", \"Source\": \"/var/lib/docker/volumes/f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b/_data\", \"Destination\": \"/webapp\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" &#125;]使用-v挂载主机上的一个文件到容器内的一个文件1docker run --rm -it -v ~/.bash_history:/root/.bash_history ubuntu /bin/bashData container (容器数据卷)在容器间共享数据,可以使用容器来进行数据的存储,这样的容器不会跑应用,而仅仅是挂载一个数据卷缺点: 容器可以被删除 优点: 可以持续重复的使用数据12345678910111213141516$ 创建一个数据卷容器$ docker create -v /dbdata --name dbstore training/webapp /bin/true$ 运行数据卷容器$ docker run -d -P --name web3 --volumes-from dbstore training/webapp python app.py$ docker inspect$ \"Mounts\": [ &#123; \"Name\": \"5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330\", \"Source\": \"/var/lib/docker/volumes/5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330/_data\", \"Destination\": \"/dbdata\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" &#125;]使用docker volume命令创建数据卷12$ docker volume create --name 数据卷名$ docker volume inspect 数据卷名使用数据卷1$ docker run -d -P --name 容器名 -v 数据卷名:/volume training/webapp python app.p","categories":[],"tags":[]},{"title":"从创建到发布-hexo的文章编写发布流程","slug":"hexo-deploy","date":"2018-02-10T16:00:00.000Z","updated":"2019-04-24T03:01:10.795Z","comments":true,"path":"2018/02/11/hexo-deploy/","link":"","permalink":"https://leo-wj910729.github.io/2018/02/11/hexo-deploy/","excerpt":"","text":"这是一段描述&lt;!-- more --&gt;快速开始创建一篇文章1$ hexo new \"一篇新的文章\"More info: Writing运行hexo服务1$ hexo serverMore info: Server生成静态文件1$ hexo generateMore info: Generating发布静态博客1$ hexo deployMore info: Deployment","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://leo-wj910729.github.io/tags/hexo/"}]}]}