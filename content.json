{"meta":{"title":"林中小屋","subtitle":"宁静致远","description":null,"author":"Henry Wang","url":"https://leo-wj910729.github.io","root":"/"},"pages":[{"title":"分类","date":"2019-04-21T06:20:23.551Z","updated":"2019-04-21T06:20:23.550Z","comments":false,"path":"categories/index.html","permalink":"https://leo-wj910729.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-21T06:20:24.372Z","updated":"2019-04-21T06:20:24.372Z","comments":false,"path":"repository/index.html","permalink":"https://leo-wj910729.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-21T06:19:30.914Z","updated":"2019-04-21T06:19:30.914Z","comments":false,"path":"tags/index.html","permalink":"https://leo-wj910729.github.io/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-04-21T06:20:50.859Z","updated":"2019-04-21T06:20:50.859Z","comments":false,"path":"/404.html","permalink":"https://leo-wj910729.github.io//404.html","excerpt":"","text":"&lt;script type=&quot;text/javascript&quot; src=&quot;//www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;&lt;%- config.url %&gt;&quot; homePageName=&quot;回到我的主页&quot;&gt;&lt;/script&gt;"},{"title":"Henry的小简历","date":"2019-04-21T04:47:25.000Z","updated":"2019-04-21T11:54:49.641Z","comments":true,"path":"about/index.html","permalink":"https://leo-wj910729.github.io/about/index.html","excerpt":"","text":"工作经历北京源石云科技有限公司上海分公司 2018.3 - 至今工作内容 负责App版本迭代,节日活动,内部管理后台,项目公用库维护,项目脚手架编写及维护,代码风格制定,分支代码合并及管理 项目经验 项目脚手架,微博内嵌商城,金币系统,大牌闪降,砍价,零元拼团,数码产品回收,拼团,各类活动页上海得仕网络科技有限公司 2017.3 - 2018.2工作内容 负责得仕彩票web端页面开发,利是利员工福利App混合开发,负责制定代码规范,代码合并及管理 项目经验 得仕彩票web端页面,利是利员工福利平台App页面开发杭州引力科技有限公司 2015.5 - 2017.2工作内容 负责公司后台页面开发,公司外包业务开发 项目经验 公司外包页面"}],"posts":[{"title":"浏览器存储方案","slug":"浏览器存储方案","date":"2019-04-26T07:08:13.000Z","updated":"2019-04-28T03:23:57.449Z","comments":true,"path":"2019/04/26/浏览器存储方案/","link":"","permalink":"https://leo-wj910729.github.io/2019/04/26/浏览器存储方案/","excerpt":"","text":"确立目标理解cookie,sessionstorage,localstorage,indexDB等浏览器存储数据方案的使用方法,优缺点学习理解cookie特征不同浏览器存储cookie的位置不同,所以不能通用不同域下的cookie是独立的我们能够操作的cookie,是在当前域,和当前域的子域中一个域下可存储的cookie有限(20个左右)存放大小也有限制(4kb)cookie可以设置过期时间(默认会话结束就销毁)配置项expiresexpires用于设定cookie的有效时间,默认为会话结束后(浏览器窗口关闭)expires必须是GMT格式的时间,可以通过new Date().toGMTString()或者 new Date().toUTCString()来获得domain,pathdomain和path共同确定了cookie的作用域,如果路径匹配成功,则会被添加到请求的头部中,如果没有设置,则会使用默认值domain的默认值为设置该cookie的网页所在的域,path默认值为设置该cookie的网页所在的目录securecookie通常使用http连接来传递数据,这种数据很容易被查看,所以cookie存储信息容易被窃取,当我们使用https等加密安全协议时,可以使用加密的数据传输cookiesecure选项用来设置cookie只会在安全的请求中才进行发送,但这样的cookie只有在传输过程中是加密的,存储到本地的cookie文件是不加密的,所以机密和敏感的信息不应该放在cookie中进行传输httpOnlycookie默认是可以通过js来进行操作的,但是如果我们不想js来操作cookie的话,可以通过设置httpOnly属性设置过该属性后,客户端无法通过js代码来进行读取,写入,删除,修改等操作,这种类型的cookie只能由服务器端进行设置sessionstoragelocalstorageindexDB讲解复述纠错反思检验成果","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"browser storage","slug":"browser-storage","permalink":"https://leo-wj910729.github.io/tags/browser-storage/"}]},{"title":"new fucntion发生了什么","slug":"new一个函数时发生了什么","date":"2019-02-26T02:59:27.000Z","updated":"2019-04-28T06:34:38.179Z","comments":true,"path":"2019/02/26/new一个函数时发生了什么/","link":"","permalink":"https://leo-wj910729.github.io/2019/02/26/new一个函数时发生了什么/","excerpt":"","text":"1234567891011121314151617181920212223function parentClass (a,b) &#123; this.a = a this.b = b&#125;new parentClass(a,b)New(parentClass, a, b)// 1.生成一个空对象// 2.将该对象的原型指向到构造函数// 3.函数的this属性赋值为该对象function New () &#123; let obj = &#123;&#125; // 生成一个空对象 let constructor = [].shift.call(arguments) // 得到构造函数 if (constructor.prototype === null) &#123; // 将对象的原型指向构造函数 obj.prototype = constructor.prototype &#125; let ret = constructor.apply(obj, [].slice.call(arguments)) // 获取构造函数的返回值 if ((typeof ret === 'object' || typeof ret === 'function') &amp;&amp; ret !== null) &#123; // 如果构造函数有返回值,且返回值为object,function类型的话,且不等于null,则返回构造函数的返回值 return ret &#125; // 否则返回对象 return obj&#125;如何将类数组转化为数组类型[].slice.call()Array.from()Array.from使用时需要注意类数组的key值需要是数字[].slice.call(arguments)将arguments转化为数组","categories":[],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"跨域解决方案","slug":"跨域解决方案","date":"2019-01-09T05:37:29.000Z","updated":"2019-04-28T06:35:29.127Z","comments":true,"path":"2019/01/09/跨域解决方案/","link":"","permalink":"https://leo-wj910729.github.io/2019/01/09/跨域解决方案/","excerpt":"","text":"跨域原因浏览器出于安全考虑,有了同源原则.只要协议,域名,端口号三者有一个不同,都会被当做是不同域解决方案JSONP利用script标签没有跨域限制的特性,通过把src的链接配置为接口的地址,并提供一个回调函数来接受数据12345678910111213function jsop(url,jsonpCb, success) &#123; let script = document.createElement('script') script.src = url script.async = true script.type = 'text/javascript' window[jsonpCb] = function (data) &#123; success &amp;&amp; success() &#125; document.body.appendChild(script)&#125;jsonp('http://xxx', 'callback', function (value) &#123; console.log(value)&#125;)CORSCORS定义了必须访问跨域资源时,浏览器如何与服务器进行沟通基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通,从而决定请求或响应是否成功兼容性,不低于IE10CORS通信的关键在服务器,服务器实现了CORS接口,就可以实现跨域通信,而浏览器端,无需做任何更改,由浏览器自动完成服务器端对CORS的支持,主要是通过Access-Contril-Allow-Origin来进行,该属性用于标识哪些域名可以跨域访问,如果浏览器检测到域名匹配则可以进行跨域访问postMessagewindow.postMessage提供了一种受控机制来规避此限制,可以安全的实现跨源通信当postMessage方法被调用时,会在页面脚本执行完毕后,会发送一个MessageEvent给目标窗口MessageEvent含四个属性1234567let messageCb = function (event) &#123; let message = event.message // 消息类型,消息名称 let source = event.source // 消息源window对象 let origin = event.origin // 消息来源地址 let data = event.data // 发送过来的消息&#125;window.addEventListener('message', messageCb, false)Nginx反向代理123456789server &#123; listen 80; server_name www.xxx.com; location / &#123; proxy_pase api.xxx.com; index index.html index.htm; &#125;&#125;","categories":[],"tags":[{"name":"browser","slug":"browser","permalink":"https://leo-wj910729.github.io/tags/browser/"}]},{"title":"Node文件系统","slug":"Node文件系统","date":"2018-11-26T08:53:53.000Z","updated":"2019-04-28T06:34:22.991Z","comments":true,"path":"2018/11/26/Node文件系统/","link":"","permalink":"https://leo-wj910729.github.io/2018/11/26/Node文件系统/","excerpt":"","text":"fs模块","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"https://leo-wj910729.github.io/tags/Node/"}]},{"title":"Git的基础操作指令","slug":"git-base","date":"2018-10-12T16:00:00.000Z","updated":"2019-04-28T06:34:10.634Z","comments":true,"path":"2018/10/13/git-base/","link":"","permalink":"https://leo-wj910729.github.io/2018/10/13/git-base/","excerpt":"","text":"全局配置Git操作配置全局信息123$ git config --global user.name \"henry\"$ git config --global user.email henry@example.com$ git config --global alias.&lt;alias-name&gt; &lt;命令名&gt; // 设置别名 如 git ci 等价于 git commit初始化本地仓库1$ git init查询当前文件状态1$ git status添加文件到git暂存区12$ git add 文件名$ git add . // 添加所有文件到暂存区提交暂存区文件到git本地仓库12$ git commit -m '提交信息'$ git commit --amend // 重新提交撤销暂存区文件1$ git reset HEAD 文件名查看远程仓库12$ git remote$ git remote -v // 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL添加远程仓库1$ git remote add &lt;remote-name&gt; &lt;url&gt; // 添加一个新的远程Git仓库拉去远程仓库到本地1$ git fetch &lt;remote-name&gt;推送到远程仓库1$ git pull &lt;remote-name&gt; &lt;branch-name&gt;修改远程仓库名称1$ git remote rename &lt;remote-name&gt; &lt;new-remote-name&gt;删除远程仓库1$ git remote rm &lt;remote-name&gt;查看所有标签12$ git tag$ git tag -l '搜索词'创建标签123$ git tag &lt;tag-name&gt; // 创建一个轻量标签$ git tag -a &lt;tag-name&gt; -m '存储在标签中的信息' // -a 创建一个携带标签信息的标签 -m 标签信息$ git tag -a &lt;tag-name&gt; 提交的校验和（或部分校验和） // 给过去的提交打标签将标签推送到远程12$ git push &lt;remote-name&gt; &lt;tag-name&gt; // 推送一个tag到远端$ git push &lt;remote-name&gt; --tags // 推送多个tag到远端删除标签12$ git tag -d &lt;tag-name&gt; // 本地删除一个指定的tag$ git push &lt;remote-name&gt; :refs/tags/&lt;tag-name&gt; // 远端删除一个指定的tag检出标签12$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag$ git checkout &lt;tag-name&gt; // 将指针指向指定的tag分支操作创建分支删除分支1$ git brach -d查询分支1$ git branch","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"git","slug":"git","permalink":"https://leo-wj910729.github.io/tags/git/"}]},{"title":"箭头函数与普通函数的区别","slug":"箭头函数与普通函数的区别","date":"2018-08-14T03:08:17.000Z","updated":"2019-04-28T06:35:01.128Z","comments":true,"path":"2018/08/14/箭头函数与普通函数的区别/","link":"","permalink":"https://leo-wj910729.github.io/2018/08/14/箭头函数与普通函数的区别/","excerpt":"","text":"箭头函数12345678910let arrowFn = (...args) =&gt; &#123; // 箭头函数没有arguments属性 // 箭头函数没有原型属性 // 箭头函数不能当做generator函数,也不能使用yield关键字 // 箭头函数作用域永远指向父级作用域,call,apply,bind都无法改变 console.log('箭头函数', arguments) // Uncaught ReferenceError: arguments is not defined console.log('箭头函数', args) // 因为没有arguments属性,使用...扩展符来获取&#125;// 箭头函数不可以作为构造函数,因为其特性,this永远指向父级作用域,而构造函数的第一步就是将this赋值为生成的空对象new arrowFn() // Uncaught TypeError: FunConstructor is not a constructor普通函数123let normalFn = function () &#123; console.log('普通函数')&#125;","categories":[],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"函数的节流","slug":"throttle","date":"2018-08-12T16:00:00.000Z","updated":"2019-04-28T06:35:45.752Z","comments":true,"path":"2018/08/13/throttle/","link":"","permalink":"https://leo-wj910729.github.io/2018/08/13/throttle/","excerpt":"","text":"定义当持续触发事件时,在规定的时间内只触发一次,如果在规定的时间内再次触发事件,则不做任何操作应用场景监听是否滚动到底部,而触发上拉加载原理时间戳形式,通过闭包保存上一次的时间戳,将其与事件触发时的时间戳进行比较,如果差值大于设定的时间,则调用事件,并记录时间戳,否则不进行任何操作定时器形式,通过闭包保存定时器,事件触发时,如果定时器为null,则执行cb,并设置新的定时器实现方法时间戳形式123456789101112function throttle (cb, delay = 16) &#123; let prevTime = 0 return function (args) &#123; let now = Date.now() let that = this let _args = args if (now &gt; prevTime + delay) &#123; fun.apply(that, _args) prevTime = now &#125; &#125;&#125;定时器形式12345678910111213function throttle (cb, delay = 16) &#123; let timer = null return function (args) &#123; let that = this let _args = args if (!timer) &#123; timer = setTimeout(function () &#123; timer = null cb.apply(that, _args) &#125;,delay) &#125; &#125;&#125;时间戳加定时器的形式12345678910111213141516171819function throttle (cb, delay = 16) &#123; let timer = null let prevTime = 0 return function (args) &#123; let that = this let _args = args let now = Date.now() let tag = delay - (now - prevTime) clearTimeout(timer) if (tag &lt; 0) &#123; cb.apply(that, delay) prevTime = Date.now() &#125; else &#123; timer = setTimeout(function () &#123; cb.apply(that, delay) &#125;, ta) &#125; &#125;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"函数的防抖","slug":"dounce","date":"2018-07-05T16:00:00.000Z","updated":"2019-04-28T06:33:34.709Z","comments":true,"path":"2018/07/06/dounce/","link":"","permalink":"https://leo-wj910729.github.io/2018/07/06/dounce/","excerpt":"","text":"定义触发时间后的一段时间内,该事件的回调函数仅会触发一次,如果在规定时间内再次触发该事件,则重新开始计算时间 游戏理解: 法师读条法术,进度条未读完再次释放则会打断上次施法应用场景用户连续操作导致事件频发触发回调用户只关系操作之后的结果(滚动条啊,搜索输入啊,这种)原理通过定时器将回调函数进行延时,在规定时间内继续回调,发现存在之前的定时器时,清空该定时器并重新设置新的定时器实现方法非立即执行版本: 事件触发=&gt; 延时=&gt; 执行回调函数 在延时中触发事件,则会重新进行延时,延时结束后执行回调函数1234567891011121314151617181920function debounce (cb, delay = 16) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(cb.timer) cb.timer = setTimout(function () &#123; cb.call(that, _args) &#125;, delay) &#125;&#125;function cb () &#123; console.log('这是一个回调函数', arguments)&#125;let debounceFn = debounce(cb)let input = document.getElementById('test-input')input.addEventListener('keyup', function (e) &#123; debounceFn(e.target.value)&#125;)立即执行版本: 事件触发=&gt; 执行回调函数=&gt; 延时 在延时中触发事件,则会重新进行延时,延时结束,并不会执行回调函数123456789101112131415161718function debounce (cb, immediate = true, delay = 16) &#123; let timer = null return function (args) &#123; let that = this let _args = args if (timer) clearTimeout(timer) if (immediate) &#123; if(!timer) cb.apply(that, args) timer = setTimeout(function () &#123; timer = null &#125;, delay) &#125; else &#123; timer = setTimeout(function () &#123; cb.apply(that, args) &#125;,delay) &#125; &#125;&#125;// 防抖就是在一段时间内如果没有操作,则执行函数,如果有操作,则清除定时器重新执行 // 节流就是在一段时间内只会触发一次函数操作","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"function","slug":"function","permalink":"https://leo-wj910729.github.io/tags/function/"}]},{"title":"垃圾回收机制","slug":"GarbageCollection","date":"2018-06-22T16:00:00.000Z","updated":"2019-04-28T06:33:08.785Z","comments":true,"path":"2018/06/23/GarbageCollection/","link":"","permalink":"https://leo-wj910729.github.io/2018/06/23/GarbageCollection/","excerpt":"","text":"垃圾回收机制javascript有内置的垃圾回收机制GC,执行环境在管理代码执行过程中使用的内存,内存的分配和回收全都由js引擎来管理内存生命周期内存分配阶段: 声明变量,函数,对象并执行时,系统会自动为其分配内存内存使用阶段: 使用变量,函数时内存回收阶段: 变量,函数被使用完毕,由GC机制回收垃圾回收机制的策略标记清除法: mark-and-sweep算法:标记阶段: GC从根开始遍历,凡是可以到达根的对象,都是仍需要使用的对象,被标记清除阶段: GC会对堆内存从头到尾进行线性遍历,发现对象没有被标记则将其占用的内存回收,标记了的对象被去除标记缺陷不能从根对象查询到的对象都会被清除GC后会产生大量的内存碎片,因为对象需要连续的内存单位,可能会导致内存碎片持续未被使用,直到内存溢出引用计数法算法:对象是否未被其他对象引用缺陷:无法处理循环引用,创建两个对象,互相引用,则这两个对象永远无法被垃圾回收,从而导致内存溢出V8垃圾回收算法chrome的v8引擎采用了分代回收策略,将内存对象分为临时对象和持久对象临时对象和持久对象的回收机制并不相同因为GC会导致js线程暂停执行,一次较长的GC可能会持续1s以上的时间,所以通过持续回收临时对象来减少GC的执行时间V8的内存限制在node中javascript可使用的内存有限制64位系统下约1.4GB,临时对象存储空间约32MB32位系统下约0.7GB,临时对象存储空间约16MB临时对象临时对象的存储空间将会被均分为两块,只有一块处于使用状态,其被称为FROM空间,另一块则闲置,被称为TO空间 GC时,将FROM空间中的临时对象中的存活对象进行标记,GC结束后将被标记对象复制到TO空间中,将FROM空间的内存清空,此时FROM空间与TO空间角色互换,如此循环**缺陷:**减少了空间的使用,换来了时间上的节省**优点:**极其适合临时对象的垃圾回收,因为临时对象生命周期短,适合该算法晋升机制当一个对象经过多次复制后依然存在,其就会被标记为持久对象,被移动至持久对象存储空间中晋升条件对象经历过临时存储空间的GC临时存储空间中的TO空间被占据25%以上持久对象持久对象的存储空间较大,存储的对象较多,使用临时对象的那种GC算法牺牲的空间太大,而且持久对象的生命周期较长持久对象的GC算法为mark-and-sweep,即标记-清除,标记非活跃对象,清除非活跃对象 但是mark-and-sweep会导致内存不连续,产生大量的内存碎片,导致内存溢出的可能性 为了解决上述问题引入了一种新的算法Mark-compact,即标记-排列整理,在标记后,将活跃对象往一端移动,移动完成后,清除边界外的内存,但该种算法的执行速度较慢,所以仅在临时对象晋升后的内存分配时使用","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://leo-wj910729.github.io/tags/javascript/"}]},{"title":"希尔排序","slug":"algorithm-shellsort","date":"2018-06-20T16:00:00.000Z","updated":"2019-04-28T06:32:41.146Z","comments":true,"path":"2018/06/21/algorithm-shellsort/","link":"","permalink":"https://leo-wj910729.github.io/2018/06/21/algorithm-shellsort/","excerpt":"","text":"算法介绍1.1 算法描述希尔排序是建立在插入排序上的改进排序方法,对排序情况较好的序列排序时,能够达到较好的排序效率1.2 算法步骤选择一个增量序列,t1, t2, ....,tj,tk 依次减少,最小为1按照增量序列的个数,对序列进行k次排序每次排序根据对应的增量ti,将待排序列分割成若干长度为m的子序列,分别对各子表进行直接插入排序.1.3 算法实现1234567891011121314151617181920funtion shellSort (arr) &#123; let len = arr.length let temp let gap = 1 while (gap &lt; len / 2) &#123; gap = gap * 2 + 1 &#125; for (;gap &gt; 0; gap = Math.floor(gap/2)) &#123; for (let i = gap; i &lt; len; i++) &#123; temp = arr[i] // 按照步进值取出对应的分块数据 arr[2]和arr[0]配对 依次类推 // 该gap值下所分的组进行插值排序 for (let j = i-gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; // arr[j] &gt; arr[i] 前值大于后值 arr[j+gap] = arr[j] // 将前值赋值给后值 &#125; arr[j+gap] = temp // &#125; &#125; return arr&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leo-wj910729.github.io/tags/algorithm/"}]},{"title":"快速排序","slug":"algorithm-quicksort","date":"2018-05-19T16:00:00.000Z","updated":"2019-04-28T06:32:49.806Z","comments":true,"path":"2018/05/20/algorithm-quicksort/","link":"","permalink":"https://leo-wj910729.github.io/2018/05/20/algorithm-quicksort/","excerpt":"","text":"算法介绍1.1 算法描述快速排序因为时间复杂度较低,且其核心思想分治法实用性强,算法难度不高,使其流行度较高1.2 算法步骤从数组中取出一个数作为基数对数组进行遍历,将大于该数的数放在基数的右边,小于该数的放在基数的左边对左侧和右侧的数组继续进行上述操作,直至左右侧只有一位数1.3 算法实现12345678910111213funtion quickSort (arr) &#123; if (!arr.isArray) return [] if (!arr.length) return [] let baseIndex = Math.floor(arr.length / 2) let baseNumber = arr.splice(baseIndex, 1)[0] let left = [] let right = [] arr.forEach(item =&gt; &#123; if (item &lt; baseNumber) left.push(item) else right.push(item) &#125;) return quickSort(left).concat(baseNumber,quickSort(right))&#125;","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://leo-wj910729.github.io/tags/algorithm/"}]},{"title":"docker基础知识","slug":"dcoker-base","date":"2018-03-25T16:00:00.000Z","updated":"2019-04-24T03:00:58.466Z","comments":true,"path":"2018/03/26/dcoker-base/","link":"","permalink":"https://leo-wj910729.github.io/2018/03/26/dcoker-base/","excerpt":"","text":"docker的核心镜像可以理解为一个只读的文件包，其中包含了虚拟环境运行最原始文件系统的内容。 每次对镜像的修改都会产生一个新的镜像层,该镜像层基于修改前的镜像。 镜像内存储的是不可变的文件。容器用于隔离虚拟环境的基础设施。 如果将镜像比作类,那么容器就是类的实例 容器是活的空间,内部文件可变网络利用一些技术,DOcker能够在容器中营造出独立的域名解析环境,这意味着我们不需要付出任何代价就可以创造出同一环境的容器 两台物理机上的docker容器,可以加入同一个虚拟网络中数据卷可以挂载在宿主操作系统中的目录上 容器内建立独立的目录持久存放数据 容器间共享","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://leo-wj910729.github.io/tags/docker/"}]},{"title":"docker-volume 数据卷","slug":"docker-volume","date":"2018-03-20T16:00:00.000Z","updated":"2019-04-24T03:00:50.962Z","comments":true,"path":"2018/03/21/docker-volume/","link":"","permalink":"https://leo-wj910729.github.io/2018/03/21/docker-volume/","excerpt":"","text":"数据卷的几种形态不使用数据卷默认情况下docker容器不使用任何volume,此时,容器的数据被保存在容器中,当容器被删除时,数据也被删除,我们可以使用docker commit 将该容器持久化为一个镜像Data volume (数据卷)使用&quot;-v 容器内目录&quot;形式,将本地一个_data目录挂载为容器内的webapp目录12345678910111213$ docker run -d -P --name web -v /webapp training/webapp python app.py$ docker inspect $ \"Mounts\": [ &#123; \"Name\": \"f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b\", \"Source\": \"/var/lib/docker/volumes/f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b/_data\", \"Destination\": \"/webapp\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" &#125;]使用-v挂载主机上的一个文件到容器内的一个文件1docker run --rm -it -v ~/.bash_history:/root/.bash_history ubuntu /bin/bashData container (容器数据卷)在容器间共享数据,可以使用容器来进行数据的存储,这样的容器不会跑应用,而仅仅是挂载一个数据卷缺点: 容器可以被删除 优点: 可以持续重复的使用数据12345678910111213141516$ 创建一个数据卷容器$ docker create -v /dbdata --name dbstore training/webapp /bin/true$ 运行数据卷容器$ docker run -d -P --name web3 --volumes-from dbstore training/webapp python app.py$ docker inspect$ \"Mounts\": [ &#123; \"Name\": \"5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330\", \"Source\": \"/var/lib/docker/volumes/5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330/_data\", \"Destination\": \"/dbdata\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" &#125;]使用docker volume命令创建数据卷12$ docker volume create --name 数据卷名$ docker volume inspect 数据卷名使用数据卷1$ docker run -d -P --name 容器名 -v 数据卷名:/volume training/webapp python app.p","categories":[],"tags":[]},{"title":"从创建到发布-hexo的文章编写发布流程","slug":"hexo-deploy","date":"2018-02-10T16:00:00.000Z","updated":"2019-04-24T03:01:10.795Z","comments":true,"path":"2018/02/11/hexo-deploy/","link":"","permalink":"https://leo-wj910729.github.io/2018/02/11/hexo-deploy/","excerpt":"","text":"这是一段描述&lt;!-- more --&gt;快速开始创建一篇文章1$ hexo new \"一篇新的文章\"More info: Writing运行hexo服务1$ hexo serverMore info: Server生成静态文件1$ hexo generateMore info: Generating发布静态博客1$ hexo deployMore info: Deployment","categories":[{"name":"学习","slug":"学习","permalink":"https://leo-wj910729.github.io/categories/学习/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://leo-wj910729.github.io/tags/hexo/"}]}]}